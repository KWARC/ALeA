
<!-- https://gist.github.com/mbostock/7607535 -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  cursor: pointer;
}

.node:hover {
  stroke: #000;
  stroke-width: 1.5px;
}

.node--leaf {
  fill: white;
}

.label {
  font: 11px "Helvetica Neue", Helvetica, Arial, sans-serif;
  text-anchor: middle;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;
}

.label,
.node--root,
.node--leaf {
  pointer-events: none;
}

</style>
<svg width="960" height="960"></svg>
<script src="d3.v7.js"></script>
<script>

var svg = d3.select("svg"),
    margin = 20,
    diameter = +svg.attr("width"),
    g = svg.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

var color = d3.scaleLinear()
    .domain([-1, 5])
    .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
    .interpolate(d3.interpolateHcl);

var pack = d3.pack()
    .size([diameter - margin, diameter - margin])
    .padding(10);

/*d3.json("circlePackingData.json", function(error, root) {
  console.log(root);
  if (error) throw error;
  /*d3.json("circlePackingData.json").then(function(root){
    console.log(root);
    if (error) throw error;*/ // -> soll neuer sein, funktioniert aber genauso nicht
function testFunc() {
  testData = {
"name": "_",
"children": [
{ "name": "Getting Started with AI: A Conceptual Framework", "size": 50, "children": [{ "name": "Logic Programming", "size": 50, "children": [{ "name": "Programming as Search", "size": 50, "children": [{ "name": "Programming Features", "size": 50, "children": [] }, { "name": "Knowledge Bases and Backtracking", "size": 50, "children": [{ "name": "match", "size": 50,  "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "Prolog search", "size": 50,  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, ] }, { "name": "Advanced Relational Programming", "size": 50, "children": [{ "name": "RTFM", "size": 50, "color": "lightred",  "children": [] }, { "name": "cut operator", "size": 50,  "children": [] }, ] }, { "name": "Running Prolog", "size": 50, "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "RTFM", "size": 50, "color": "lightred",  "children": [] }, { "name": "match", "size": 50,  "children": [] }, { "name": "cut operator", "size": 50,  "children": [] }, { "name": "Prolog search", "size": 50,  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, ] }, { "name": "Introduction to Logic Programming and ProLog", "size": 50, "children": [{ "name": "knowledge base", "size": 50,  "children": [] }, { "name": "body", "size": 50,  "children": [] }, { "name": "literal", "size": 50, "color": "red",  "children": [] }, { "name": "succeed", "size": 50,  "children": [] }, { "name": "Prolog", "size": 50, "color": "lightred",  "children": [] }, { "name": "head", "size": 50,  "children": [] }, { "name": "Prolog program", "size": 50,  "children": [] }, { "name": "conjIRule", "size": 50,  "children": [] }, { "name": "rule", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "backchain", "size": 50,  "children": [] }, { "name": "constant", "size": 50, "color": "lightred",  "children": [] }, { "name": "fact", "size": 50,  "children": [] }, { "name": "term", "size": 50, "color": "lightred",  "children": [] }, { "name": "goal", "size": 50,  "children": [] }, { "name": "fail", "size": 50,  "children": [] }, { "name": "answer substitution", "size": 50,  "children": [] }, { "name": "function", "size": 50,  "children": [] }, { "name": "query", "size": 50, "color": "red",  "children": [] }, { "name": "clause", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "knowledge base", "size": 50,  "children": [] }, { "name": "RTFM", "size": 50, "color": "lightred",  "children": [] }, { "name": "body", "size": 50,  "children": [] }, { "name": "literal", "size": 50, "color": "red",  "children": [] }, { "name": "succeed", "size": 50,  "children": [] }, { "name": "Prolog search", "size": 50,  "children": [] }, { "name": "Prolog", "size": 50, "color": "lightred",  "children": [] }, { "name": "match", "size": 50,  "children": [] }, { "name": "head", "size": 50,  "children": [] }, { "name": "Prolog program", "size": 50,  "children": [] }, { "name": "conjIRule", "size": 50,  "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "rule", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "backchain", "size": 50,  "children": [] }, { "name": "constant", "size": 50, "color": "lightred",  "children": [] }, { "name": "fact", "size": 50,  "children": [] }, { "name": "term", "size": 50, "color": "lightred",  "children": [] }, { "name": "goal", "size": 50,  "children": [] }, { "name": "fail", "size": 50,  "children": [] }, { "name": "answer substitution", "size": 50,  "children": [] }, { "name": "function", "size": 50,  "children": [] }, { "name": "query", "size": 50, "color": "red",  "children": [] }, { "name": "cut operator", "size": 50,  "children": [] }, { "name": "clause", "size": 50, "color": "red",  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, ] }, { "name": "Rational Agents: a Unifying Framework for Artificial Intelligence", "size": 50, "children": [{ "name": "Good Behavior ?   Rationality", "size": 50, "children": [{ "name": "autonomous", "size": 50,  "children": [] }, { "name": "PEAS", "size": 50,  "children": [] }, { "name": "rational", "size": 50,  "children": [] }, { "name": "performance measure", "size": 50,  "children": [] }, ] }, { "name": "Agents and Environments as a Framework for AI", "size": 50, "children": [{ "name": "actuator", "size": 50, "color": "red",  "children": [] }, { "name": "percept", "size": 50,  "children": [] }, { "name": "agent architecture", "size": 50,  "children": [] }, { "name": "sensor", "size": 50, "color": "red",  "children": [] }, { "name": "agent schema", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "perceive", "size": 50, "color": "red",  "children": [] }, { "name": "act", "size": 50, "color": "red",  "children": [] }, { "name": "environment", "size": 50, "color": "red",  "children": [] }, { "name": "agent program", "size": 50,  "children": [] }, { "name": "percepts", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "agent function", "size": 50,  "children": [] }, { "name": "agent", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Representing the Environment in Agents", "size": 50, "children": [{ "name": "attribute value", "size": 50,  "children": [] }, { "name": "factored", "size": 50,  "children": [] }, { "name": "attribute", "size": 50,  "children": [] }, { "name": "structured", "size": 50,  "children": [] }, { "name": "atomic", "size": 50,  "children": [] }, ] }, { "name": "Types of Agents", "size": 50, "children": [{ "name": "goal", "size": 50,  "children": [] }, { "name": "learning element", "size": 50,  "children": [] }, { "name": "transition model", "size": 50,  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "problem generator", "size": 50,  "children": [] }, { "name": "world model", "size": 50,  "children": [] }, { "name": "simple reflex agent", "size": 50,  "children": [] }, { "name": "learning agent", "size": 50,  "children": [] }, { "name": "utility", "size": 50,  "children": [] }, { "name": "goal-based agent", "size": 50,  "children": [] }, { "name": "performance standard", "size": 50,  "children": [] }, { "name": "critic", "size": 50,  "children": [] }, { "name": "action function", "size": 50,  "children": [] }, { "name": "performance element", "size": 50,  "children": [] }, { "name": "goals", "size": 50,  "children": [] }, { "name": "utility-based agent", "size": 50,  "children": [] }, { "name": "model-based agent", "size": 50,  "children": [] }, { "name": "goal function", "size": 50,  "children": [] }, { "name": "sensor model", "size": 50,  "children": [] }, ] }, { "name": "Classifying Environments", "size": 50, "children": [{ "name": "type", "size": 50,  "children": [] }, { "name": "semidynamic", "size": 50,  "children": [] }, { "name": "single agent", "size": 50,  "children": [] }, { "name": "fully observable", "size": 50,  "children": [] }, { "name": "sequential", "size": 50,  "children": [] }, { "name": "dynamic", "size": 50,  "children": [] }, { "name": "deterministic", "size": 50,  "children": [] }, { "name": "discrete", "size": 50,  "children": [] }, { "name": "episode", "size": 50,  "children": [] }, { "name": "static", "size": 50,  "children": [] }, { "name": "multi agent", "size": 50,  "children": [] }, { "name": "stochastic", "size": 50,  "children": [] }, { "name": "episodic", "size": 50,  "children": [] }, { "name": "partially observable", "size": 50,  "children": [] }, { "name": "continuous", "size": 50,  "children": [] }, ] }, { "name": "Introduction: Rationality in Artificial Intelligence", "size": 50, "children": [{ "name": "behaviorism", "size": 50,  "children": [] }, { "name": "Cognitive Neuroscience", "size": 50,  "children": [] }, { "name": "imitation game", "size": 50,  "children": [] }, { "name": "logic", "size": 50,  "children": [] }, { "name": "rational behavior", "size": 50,  "children": [] }, { "name": "Cognitive Science", "size": 50,  "children": [] }, { "name": "Turing test", "size": 50,  "children": [] }, { "name": "prescriptive", "size": 50,  "children": [] }, { "name": "cognitive revolution", "size": 50,  "children": [] }, { "name": "Normative", "size": 50,  "children": [] }, { "name": "agent", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "type", "size": 50,  "children": [] }, { "name": "actuator", "size": 50, "color": "red",  "children": [] }, { "name": "sensor", "size": 50, "color": "red",  "children": [] }, { "name": "learning element", "size": 50,  "children": [] }, { "name": "problem generator", "size": 50,  "children": [] }, { "name": "world model", "size": 50,  "children": [] }, { "name": "static", "size": 50,  "children": [] }, { "name": "agent function", "size": 50,  "children": [] }, { "name": "learning agent", "size": 50,  "children": [] }, { "name": "episodic", "size": 50,  "children": [] }, { "name": "goal-based agent", "size": 50,  "children": [] }, { "name": "fully observable", "size": 50,  "children": [] }, { "name": "critic", "size": 50,  "children": [] }, { "name": "goals", "size": 50,  "children": [] }, { "name": "deterministic", "size": 50,  "children": [] }, { "name": "prescriptive", "size": 50,  "children": [] }, { "name": "model-based agent", "size": 50,  "children": [] }, { "name": "attribute value", "size": 50,  "children": [] }, { "name": "partially observable", "size": 50,  "children": [] }, { "name": "percept", "size": 50,  "children": [] }, { "name": "PEAS", "size": 50,  "children": [] }, { "name": "goal", "size": 50,  "children": [] }, { "name": "logic", "size": 50,  "children": [] }, { "name": "agent schema", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "perceive", "size": 50, "color": "red",  "children": [] }, { "name": "dynamic", "size": 50,  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "environment", "size": 50, "color": "red",  "children": [] }, { "name": "continuous", "size": 50,  "children": [] }, { "name": "Cognitive Neuroscience", "size": 50,  "children": [] }, { "name": "factored", "size": 50,  "children": [] }, { "name": "structured", "size": 50,  "children": [] }, { "name": "atomic", "size": 50,  "children": [] }, { "name": "autonomous", "size": 50,  "children": [] }, { "name": "discrete", "size": 50,  "children": [] }, { "name": "utility-based agent", "size": 50,  "children": [] }, { "name": "rational", "size": 50,  "children": [] }, { "name": "performance measure", "size": 50,  "children": [] }, { "name": "stochastic", "size": 50,  "children": [] }, { "name": "goal function", "size": 50,  "children": [] }, { "name": "single agent", "size": 50,  "children": [] }, { "name": "attribute", "size": 50,  "children": [] }, { "name": "rational behavior", "size": 50,  "children": [] }, { "name": "Turing test", "size": 50,  "children": [] }, { "name": "transition model", "size": 50,  "children": [] }, { "name": "cognitive revolution", "size": 50,  "children": [] }, { "name": "utility", "size": 50,  "children": [] }, { "name": "performance standard", "size": 50,  "children": [] }, { "name": "semidynamic", "size": 50,  "children": [] }, { "name": "action function", "size": 50,  "children": [] }, { "name": "act", "size": 50, "color": "red",  "children": [] }, { "name": "episode", "size": 50,  "children": [] }, { "name": "multi agent", "size": 50,  "children": [] }, { "name": "percepts", "size": 50,  "children": [] }, { "name": "agent", "size": 50, "color": "red",  "children": [] }, { "name": "agent architecture", "size": 50,  "children": [] }, { "name": "sequential", "size": 50,  "children": [] }, { "name": "Cognitive Science", "size": 50,  "children": [] }, { "name": "simple reflex agent", "size": 50,  "children": [] }, { "name": "agent program", "size": 50,  "children": [] }, { "name": "Normative", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "behaviorism", "size": 50,  "children": [] }, { "name": "imitation game", "size": 50,  "children": [] }, { "name": "performance element", "size": 50,  "children": [] }, { "name": "sensor model", "size": 50,  "children": [] }, ] }, { "name": "Recap of Prerequisites from Math & Theoretical Computer Science", "size": 50, "children": [{ "name": "Mathematical Language Recap", "size": 50, "children": [{ "name": "terminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "body", "size": 50, "color": "red",  "children": [] }, { "name": "symbol", "size": 50, "color": "red",  "children": [] }, { "name": "grammar", "size": 50, "color": "red",  "children": [] }, { "name": "prul", "size": 50, "color": "red",  "children": [] }, { "name": "terminal", "size": 50,  "children": [] }, { "name": "non-terminal", "size": 50,  "children": [] }, { "name": "gnull", "size": 50,  "children": [] }, { "name": "nonterminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "structure signature", "size": 50,  "children": [] }, { "name": "class of sets", "size": 50,  "children": [] }, { "name": "gseq", "size": 50,  "children": [] }, { "name": "start symbol", "size": 50,  "children": [] }, { "name": "production rule", "size": 50, "color": "red",  "children": [] }, { "name": "head", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Recap: Formal Languages and Grammars", "size": 50, "children": [{ "name": "kleenestar", "size": 50, "color": "red",  "children": [] }, { "name": "terminal", "size": 50,  "children": [] }, { "name": "gnull", "size": 50,  "children": [] }, { "name": "nonterminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "CFL", "size": 50, "color": "red",  "children": [] }, { "name": "BNFgrammar", "size": 50,  "children": [] }, { "name": "kleeneplus", "size": 50, "color": "red",  "children": [] }, { "name": "lexical", "size": 50, "color": "red",  "children": [] }, { "name": "language", "size": 50, "color": "red",  "children": [] }, { "name": "alternative", "size": 50, "color": "red",  "children": [] }, { "name": "derives", "size": 50, "color": "red",  "children": [] }, { "name": "context-sensitive", "size": 50, "color": "red",  "children": [] }, { "name": "BNFplus", "size": 50,  "children": [] }, { "name": "derivesOnestep", "size": 50,  "children": [] }, { "name": "derivation", "size": 50,  "children": [] }, { "name": "lkleeneplus", "size": 50,  "children": [] }, { "name": "closure", "size": 50, "color": "red",  "children": [] }, { "name": "derivesOnestepRule", "size": 50,  "children": [] }, { "name": "gsderivesOp", "size": 50,  "children": [] }, { "name": "CFG", "size": 50, "color": "red",  "children": [] }, { "name": "regular", "size": 50, "color": "red",  "children": [] }, { "name": "concatenation", "size": 50, "color": "red",  "children": [] }, { "name": "parse", "size": 50,  "children": [] }, { "name": "gderivesOnestepRuleOp", "size": 50,  "children": [] }, { "name": "character set", "size": 50,  "children": [] }, { "name": "repetition", "size": 50,  "children": [] }, { "name": "accept", "size": 50, "color": "red",  "children": [] }, { "name": "optional", "size": 50,  "children": [] }, { "name": "structural", "size": 50, "color": "red",  "children": [] }, { "name": "BNF", "size": 50,  "children": [] }, { "name": "grammar", "size": 50, "color": "red",  "children": [] }, { "name": "BNFgloss", "size": 50,  "children": [] }, { "name": "vocabulary", "size": 50,  "children": [] }, { "name": "prul", "size": 50, "color": "red",  "children": [] }, { "name": "BNFseq", "size": 50,  "children": [] }, { "name": "production rule", "size": 50, "color": "red",  "children": [] }, { "name": "terminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "head", "size": 50, "color": "red",  "children": [] }, { "name": "body", "size": 50, "color": "red",  "children": [] }, { "name": "formal language", "size": 50, "color": "red",  "children": [] }, { "name": "lexicon", "size": 50, "color": "red",  "children": [] }, { "name": "BNFterm", "size": 50,  "children": [] }, { "name": "sentential form", "size": 50, "color": "red",  "children": [] }, { "name": "length", "size": 50, "color": "lightred",  "children": [] }, { "name": "concatenation", "size": 50, "color": "lightred",  "children": [] }, { "name": "sentence", "size": 50, "color": "red",  "children": [] }, { "name": "grouping", "size": 50,  "children": [] }, { "name": "character", "size": 50, "color": "red",  "children": [] }, { "name": "non-terminal", "size": 50,  "children": [] }, { "name": "gderivesOnestepOp", "size": 50,  "children": [] }, { "name": "srep", "size": 50, "color": "red",  "children": [] }, { "name": "BNFrule", "size": 50, "color": "red",  "children": [] }, { "name": "gseq", "size": 50,  "children": [] }, { "name": "start symbol", "size": 50,  "children": [] }, { "name": "gsderivation", "size": 50,  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "lexical category", "size": 50, "color": "red",  "children": [] }, { "name": "BNFcat", "size": 50,  "children": [] }, { "name": "word", "size": 50, "color": "red",  "children": [] }, { "name": "symbol", "size": 50, "color": "red",  "children": [] }, { "name": "complement", "size": 50,  "children": [] }, { "name": "phrasal category", "size": 50, "color": "red",  "children": [] }, { "name": "empty word", "size": 50, "color": "red",  "children": [] }, { "name": "context-free", "size": 50, "color": "red",  "children": [] }, { "name": "alphabet", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Recap: Complexity Analysis in AI?", "size": 50, "children": [{ "name": "ctxgiven", "size": 50,  "children": [] }, { "name": "timeoverrun", "size": 50,  "children": [] }, { "name": "tcgiven", "size": 50,  "children": [] }, ] }, { "name": "kleenestar", "size": 50, "color": "red",  "children": [] }, { "name": "terminal", "size": 50,  "children": [] }, { "name": "gnull", "size": 50,  "children": [] }, { "name": "nonterminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "CFL", "size": 50, "color": "red",  "children": [] }, { "name": "BNFgrammar", "size": 50,  "children": [] }, { "name": "kleeneplus", "size": 50, "color": "red",  "children": [] }, { "name": "lexical", "size": 50, "color": "red",  "children": [] }, { "name": "language", "size": 50, "color": "red",  "children": [] }, { "name": "alternative", "size": 50, "color": "red",  "children": [] }, { "name": "derives", "size": 50, "color": "red",  "children": [] }, { "name": "context-sensitive", "size": 50, "color": "red",  "children": [] }, { "name": "BNFplus", "size": 50,  "children": [] }, { "name": "derivesOnestep", "size": 50,  "children": [] }, { "name": "derivation", "size": 50,  "children": [] }, { "name": "lkleeneplus", "size": 50,  "children": [] }, { "name": "timeoverrun", "size": 50,  "children": [] }, { "name": "closure", "size": 50, "color": "red",  "children": [] }, { "name": "tcgiven", "size": 50,  "children": [] }, { "name": "class of sets", "size": 50,  "children": [] }, { "name": "derivesOnestepRule", "size": 50,  "children": [] }, { "name": "gsderivesOp", "size": 50,  "children": [] }, { "name": "CFG", "size": 50, "color": "red",  "children": [] }, { "name": "regular", "size": 50, "color": "red",  "children": [] }, { "name": "concatenation", "size": 50, "color": "red",  "children": [] }, { "name": "parse", "size": 50,  "children": [] }, { "name": "gderivesOnestepRuleOp", "size": 50,  "children": [] }, { "name": "character set", "size": 50,  "children": [] }, { "name": "repetition", "size": 50,  "children": [] }, { "name": "accept", "size": 50, "color": "red",  "children": [] }, { "name": "optional", "size": 50,  "children": [] }, { "name": "structure signature", "size": 50,  "children": [] }, { "name": "structural", "size": 50, "color": "red",  "children": [] }, { "name": "BNF", "size": 50,  "children": [] }, { "name": "grammar", "size": 50, "color": "red",  "children": [] }, { "name": "BNFgloss", "size": 50,  "children": [] }, { "name": "vocabulary", "size": 50,  "children": [] }, { "name": "prul", "size": 50, "color": "red",  "children": [] }, { "name": "BNFseq", "size": 50,  "children": [] }, { "name": "production rule", "size": 50, "color": "red",  "children": [] }, { "name": "terminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "head", "size": 50, "color": "red",  "children": [] }, { "name": "body", "size": 50, "color": "red",  "children": [] }, { "name": "formal language", "size": 50, "color": "red",  "children": [] }, { "name": "lexicon", "size": 50, "color": "red",  "children": [] }, { "name": "BNFterm", "size": 50,  "children": [] }, { "name": "sentential form", "size": 50, "color": "red",  "children": [] }, { "name": "length", "size": 50, "color": "lightred",  "children": [] }, { "name": "concatenation", "size": 50, "color": "lightred",  "children": [] }, { "name": "sentence", "size": 50, "color": "red",  "children": [] }, { "name": "grouping", "size": 50,  "children": [] }, { "name": "character", "size": 50, "color": "red",  "children": [] }, { "name": "non-terminal", "size": 50,  "children": [] }, { "name": "gderivesOnestepOp", "size": 50,  "children": [] }, { "name": "srep", "size": 50, "color": "red",  "children": [] }, { "name": "BNFrule", "size": 50, "color": "red",  "children": [] }, { "name": "gseq", "size": 50,  "children": [] }, { "name": "start symbol", "size": 50,  "children": [] }, { "name": "gsderivation", "size": 50,  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "lexical category", "size": 50, "color": "red",  "children": [] }, { "name": "BNFcat", "size": 50,  "children": [] }, { "name": "word", "size": 50, "color": "red",  "children": [] }, { "name": "ctxgiven", "size": 50,  "children": [] }, { "name": "symbol", "size": 50, "color": "red",  "children": [] }, { "name": "complement", "size": 50,  "children": [] }, { "name": "phrasal category", "size": 50, "color": "red",  "children": [] }, { "name": "empty word", "size": 50, "color": "red",  "children": [] }, { "name": "context-free", "size": 50, "color": "red",  "children": [] }, { "name": "alphabet", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "type", "size": 50,  "children": [] }, { "name": "body", "size": 50,  "children": [] }, { "name": "learning element", "size": 50,  "children": [] }, { "name": "world model", "size": 50,  "children": [] }, { "name": "episodic", "size": 50,  "children": [] }, { "name": "learning agent", "size": 50,  "children": [] }, { "name": "BNFgrammar", "size": 50,  "children": [] }, { "name": "kleeneplus", "size": 50, "color": "red",  "children": [] }, { "name": "fully observable", "size": 50,  "children": [] }, { "name": "lexical", "size": 50, "color": "red",  "children": [] }, { "name": "context-sensitive", "size": 50, "color": "red",  "children": [] }, { "name": "goal", "size": 50,  "children": [] }, { "name": "derivesOnestep", "size": 50,  "children": [] }, { "name": "answer substitution", "size": 50,  "children": [] }, { "name": "prescriptive", "size": 50,  "children": [] }, { "name": "model-based agent", "size": 50,  "children": [] }, { "name": "attribute value", "size": 50,  "children": [] }, { "name": "percept", "size": 50,  "children": [] }, { "name": "lkleeneplus", "size": 50,  "children": [] }, { "name": "goal", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "perceive", "size": 50, "color": "red",  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "match", "size": 50,  "children": [] }, { "name": "rule", "size": 50,  "children": [] }, { "name": "gsderivesOp", "size": 50,  "children": [] }, { "name": "structured", "size": 50,  "children": [] }, { "name": "atomic", "size": 50,  "children": [] }, { "name": "character set", "size": 50,  "children": [] }, { "name": "accept", "size": 50, "color": "red",  "children": [] }, { "name": "structure signature", "size": 50,  "children": [] }, { "name": "rational", "size": 50,  "children": [] }, { "name": "performance measure", "size": 50,  "children": [] }, { "name": "BNF", "size": 50,  "children": [] }, { "name": "grammar", "size": 50, "color": "red",  "children": [] }, { "name": "clause", "size": 50, "color": "red",  "children": [] }, { "name": "single agent", "size": 50,  "children": [] }, { "name": "attribute", "size": 50,  "children": [] }, { "name": "rational behavior", "size": 50,  "children": [] }, { "name": "prul", "size": 50, "color": "red",  "children": [] }, { "name": "Turing test", "size": 50,  "children": [] }, { "name": "BNFseq", "size": 50,  "children": [] }, { "name": "transition model", "size": 50,  "children": [] }, { "name": "cognitive revolution", "size": 50,  "children": [] }, { "name": "terminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "performance standard", "size": 50,  "children": [] }, { "name": "action function", "size": 50,  "children": [] }, { "name": "episode", "size": 50,  "children": [] }, { "name": "BNFterm", "size": 50,  "children": [] }, { "name": "sentential form", "size": 50, "color": "red",  "children": [] }, { "name": "agent", "size": 50, "color": "red",  "children": [] }, { "name": "sentence", "size": 50, "color": "red",  "children": [] }, { "name": "agent architecture", "size": 50,  "children": [] }, { "name": "sequential", "size": 50,  "children": [] }, { "name": "Cognitive Science", "size": 50,  "children": [] }, { "name": "non-terminal", "size": 50,  "children": [] }, { "name": "agent program", "size": 50,  "children": [] }, { "name": "start symbol", "size": 50,  "children": [] }, { "name": "gsderivation", "size": 50,  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "lexical category", "size": 50, "color": "red",  "children": [] }, { "name": "conjIRule", "size": 50,  "children": [] }, { "name": "BNFcat", "size": 50,  "children": [] }, { "name": "imitation game", "size": 50,  "children": [] }, { "name": "symbol", "size": 50, "color": "red",  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "complement", "size": 50,  "children": [] }, { "name": "term", "size": 50, "color": "lightred",  "children": [] }, { "name": "function", "size": 50,  "children": [] }, { "name": "empty word", "size": 50, "color": "red",  "children": [] }, { "name": "context-free", "size": 50, "color": "red",  "children": [] }, { "name": "alphabet", "size": 50, "color": "red",  "children": [] }, { "name": "production rule", "size": 50, "color": "red",  "children": [] }, { "name": "actuator", "size": 50, "color": "red",  "children": [] }, { "name": "knowledge base", "size": 50,  "children": [] }, { "name": "RTFM", "size": 50, "color": "lightred",  "children": [] }, { "name": "sensor", "size": 50, "color": "red",  "children": [] }, { "name": "kleenestar", "size": 50, "color": "red",  "children": [] }, { "name": "terminal", "size": 50,  "children": [] }, { "name": "literal", "size": 50, "color": "red",  "children": [] }, { "name": "gnull", "size": 50,  "children": [] }, { "name": "problem generator", "size": 50,  "children": [] }, { "name": "nonterminal symbol", "size": 50, "color": "red",  "children": [] }, { "name": "static", "size": 50,  "children": [] }, { "name": "agent function", "size": 50,  "children": [] }, { "name": "CFL", "size": 50, "color": "red",  "children": [] }, { "name": "Prolog program", "size": 50,  "children": [] }, { "name": "goal-based agent", "size": 50,  "children": [] }, { "name": "critic", "size": 50,  "children": [] }, { "name": "alternative", "size": 50, "color": "red",  "children": [] }, { "name": "derives", "size": 50, "color": "red",  "children": [] }, { "name": "goals", "size": 50,  "children": [] }, { "name": "deterministic", "size": 50,  "children": [] }, { "name": "fail", "size": 50,  "children": [] }, { "name": "BNFplus", "size": 50,  "children": [] }, { "name": "cut operator", "size": 50,  "children": [] }, { "name": "partially observable", "size": 50,  "children": [] }, { "name": "derivation", "size": 50,  "children": [] }, { "name": "PEAS", "size": 50,  "children": [] }, { "name": "logic", "size": 50,  "children": [] }, { "name": "agent schema", "size": 50,  "children": [] }, { "name": "timeoverrun", "size": 50,  "children": [] }, { "name": "closure", "size": 50, "color": "red",  "children": [] }, { "name": "tcgiven", "size": 50,  "children": [] }, { "name": "succeed", "size": 50,  "children": [] }, { "name": "dynamic", "size": 50,  "children": [] }, { "name": "environment", "size": 50, "color": "red",  "children": [] }, { "name": "class of sets", "size": 50,  "children": [] }, { "name": "derivesOnestepRule", "size": 50,  "children": [] }, { "name": "continuous", "size": 50,  "children": [] }, { "name": "CFG", "size": 50, "color": "red",  "children": [] }, { "name": "Cognitive Neuroscience", "size": 50,  "children": [] }, { "name": "factored", "size": 50,  "children": [] }, { "name": "concatenation", "size": 50, "color": "red",  "children": [] }, { "name": "regular", "size": 50, "color": "red",  "children": [] }, { "name": "parse", "size": 50,  "children": [] }, { "name": "autonomous", "size": 50,  "children": [] }, { "name": "discrete", "size": 50,  "children": [] }, { "name": "gderivesOnestepRuleOp", "size": 50,  "children": [] }, { "name": "utility-based agent", "size": 50,  "children": [] }, { "name": "repetition", "size": 50,  "children": [] }, { "name": "optional", "size": 50,  "children": [] }, { "name": "stochastic", "size": 50,  "children": [] }, { "name": "structural", "size": 50, "color": "red",  "children": [] }, { "name": "goal function", "size": 50,  "children": [] }, { "name": "BNFgloss", "size": 50,  "children": [] }, { "name": "vocabulary", "size": 50,  "children": [] }, { "name": "utility", "size": 50,  "children": [] }, { "name": "head", "size": 50, "color": "red",  "children": [] }, { "name": "semidynamic", "size": 50,  "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "body", "size": 50, "color": "red",  "children": [] }, { "name": "act", "size": 50, "color": "red",  "children": [] }, { "name": "constant", "size": 50, "color": "lightred",  "children": [] }, { "name": "fact", "size": 50,  "children": [] }, { "name": "formal language", "size": 50, "color": "red",  "children": [] }, { "name": "lexicon", "size": 50, "color": "red",  "children": [] }, { "name": "multi agent", "size": 50,  "children": [] }, { "name": "percepts", "size": 50,  "children": [] }, { "name": "length", "size": 50, "color": "lightred",  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, { "name": "concatenation", "size": 50, "color": "lightred",  "children": [] }, { "name": "grouping", "size": 50,  "children": [] }, { "name": "character", "size": 50, "color": "red",  "children": [] }, { "name": "gderivesOnestepOp", "size": 50,  "children": [] }, { "name": "Prolog search", "size": 50,  "children": [] }, { "name": "Normative", "size": 50,  "children": [] }, { "name": "simple reflex agent", "size": 50,  "children": [] }, { "name": "srep", "size": 50, "color": "red",  "children": [] }, { "name": "Prolog", "size": 50, "color": "lightred",  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "gseq", "size": 50,  "children": [] }, { "name": "BNFrule", "size": 50, "color": "red",  "children": [] }, { "name": "head", "size": 50,  "children": [] }, { "name": "behaviorism", "size": 50,  "children": [] }, { "name": "word", "size": 50, "color": "red",  "children": [] }, { "name": "ctxgiven", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "backchain", "size": 50,  "children": [] }, { "name": "phrasal category", "size": 50, "color": "red",  "children": [] }, { "name": "performance element", "size": 50,  "children": [] }, { "name": "query", "size": 50, "color": "red",  "children": [] }, { "name": "language", "size": 50, "color": "red",  "children": [] }, { "name": "sensor model", "size": 50,  "children": [] }, ] }, { "name": "General Problem Solving", "size": 50, "children": [{ "name": "Constraint Satisfaction Problems", "size": 50, "children": [{ "name": "The Waltz Algorithm", "size": 50, "children": [] }, { "name": "Constraint Networks: Formalizing Binary CSPs", "size": 50, "children": [{ "name": "extend", "size": 50,  "children": [] }, { "name": "legal", "size": 50,  "children": [] }, { "name": "constraint network", "size": 50, "color": "lightred",  "children": [] }, { "name": "conflict", "size": 50,  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "solution", "size": 50,  "children": [] }, { "name": "domain", "size": 50, "color": "lightred",  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "satisfy", "size": 50,  "children": [] }, { "name": "domain", "size": 50, "color": "red",  "children": [] }, { "name": "constraint", "size": 50, "color": "lightred",  "children": [] }, { "name": "constraint graph", "size": 50, "color": "red",  "children": [] }, { "name": "CSP", "size": 50, "color": "red",  "children": [] }, { "name": "unary constraint", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "violate", "size": 50,  "children": [] }, ] }, { "name": "Conclusion & Preview", "size": 50, "children": [] }, { "name": "CSP as Search", "size": 50, "children": [{ "name": "least constraining value", "size": 50,  "children": [] }, { "name": "value ordering", "size": 50,  "children": [] }, { "name": "induced search problem", "size": 50,  "children": [] }, { "name": "degree heuristic", "size": 50,  "children": [] }, { "name": "backtracking search", "size": 50,  "children": [] }, { "name": "variable ordering", "size": 50,  "children": [] }, { "name": "least constraining value heuristic", "size": 50,  "children": [] }, { "name": "most constraining", "size": 50,  "children": [] }, { "name": "MRV", "size": 50,  "children": [] }, ] }, { "name": "Constraint Satisfaction Problems: Motivation", "size": 50, "children": [{ "name": "bluecolor", "size": 50,  "children": [] }, { "name": "Tvar", "size": 50,  "children": [] }, { "name": "greencolor", "size": 50,  "children": [] }, { "name": "domainof", "size": 50, "color": "red",  "children": [] }, { "name": "NSWvar", "size": 50,  "children": [] }, { "name": "solution", "size": 50,  "children": [] }, { "name": "redcolor", "size": 50,  "children": [] }, { "name": "NTvar", "size": 50,  "children": [] }, { "name": "WAvar", "size": 50,  "children": [] }, { "name": "map coloring", "size": 50,  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "SAvar", "size": 50,  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "constraint", "size": 50,  "children": [] }, { "name": "solve", "size": 50,  "children": [] }, { "name": "Qvar", "size": 50,  "children": [] }, { "name": "var", "size": 50,  "children": [] }, { "name": "constraint solving", "size": 50,  "children": [] }, { "name": "CSP", "size": 50, "color": "red",  "children": [] }, { "name": "Vvar", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, ] }, { "name": "CSP: Towards a Formal Definition", "size": 50, "children": [{ "name": "higher-order", "size": 50,  "children": [] }, { "name": "constrained optimization problem", "size": 50,  "children": [] }, { "name": "preference", "size": 50,  "children": [] }, { "name": "unary", "size": 50,  "children": [] }, { "name": "binary", "size": 50,  "children": [] }, { "name": "crypto-arithmetic puzzle", "size": 50,  "children": [] }, { "name": "order", "size": 50,  "children": [] }, { "name": "continuous", "size": 50,  "children": [] }, { "name": "constraint graph", "size": 50, "color": "red",  "children": [] }, { "name": "ternary", "size": 50,  "children": [] }, { "name": "binary CSP", "size": 50,  "children": [] }, { "name": "auxiliary variable", "size": 50,  "children": [] }, { "name": "discrete", "size": 50,  "children": [] }, ] }, { "name": "legal", "size": 50,  "children": [] }, { "name": "unary", "size": 50,  "children": [] }, { "name": "bluecolor", "size": 50,  "children": [] }, { "name": "variable ordering", "size": 50,  "children": [] }, { "name": "constraint network", "size": 50, "color": "lightred",  "children": [] }, { "name": "continuous", "size": 50,  "children": [] }, { "name": "order", "size": 50,  "children": [] }, { "name": "NSWvar", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "solution", "size": 50,  "children": [] }, { "name": "redcolor", "size": 50,  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "constrained optimization problem", "size": 50,  "children": [] }, { "name": "SAvar", "size": 50,  "children": [] }, { "name": "value ordering", "size": 50,  "children": [] }, { "name": "induced search problem", "size": 50,  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "unary constraint", "size": 50,  "children": [] }, { "name": "satisfy", "size": 50,  "children": [] }, { "name": "domain", "size": 50, "color": "red",  "children": [] }, { "name": "constraint", "size": 50, "color": "lightred",  "children": [] }, { "name": "constraint graph", "size": 50, "color": "red",  "children": [] }, { "name": "auxiliary variable", "size": 50,  "children": [] }, { "name": "Vvar", "size": 50,  "children": [] }, { "name": "MRV", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "extend", "size": 50,  "children": [] }, { "name": "preference", "size": 50,  "children": [] }, { "name": "least constraining value", "size": 50,  "children": [] }, { "name": "degree heuristic", "size": 50,  "children": [] }, { "name": "backtracking search", "size": 50,  "children": [] }, { "name": "Tvar", "size": 50,  "children": [] }, { "name": "greencolor", "size": 50,  "children": [] }, { "name": "crypto-arithmetic puzzle", "size": 50,  "children": [] }, { "name": "domainof", "size": 50, "color": "red",  "children": [] }, { "name": "conflict", "size": 50,  "children": [] }, { "name": "ternary", "size": 50,  "children": [] }, { "name": "binary CSP", "size": 50,  "children": [] }, { "name": "least constraining value heuristic", "size": 50,  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "NTvar", "size": 50,  "children": [] }, { "name": "WAvar", "size": 50,  "children": [] }, { "name": "map coloring", "size": 50,  "children": [] }, { "name": "domain", "size": 50, "color": "lightred",  "children": [] }, { "name": "higher-order", "size": 50,  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "constraint", "size": 50,  "children": [] }, { "name": "binary", "size": 50,  "children": [] }, { "name": "solve", "size": 50,  "children": [] }, { "name": "Qvar", "size": 50,  "children": [] }, { "name": "var", "size": 50,  "children": [] }, { "name": "constraint solving", "size": 50,  "children": [] }, { "name": "most constraining", "size": 50,  "children": [] }, { "name": "CSP", "size": 50, "color": "red",  "children": [] }, { "name": "discrete", "size": 50,  "children": [] }, { "name": "violate", "size": 50,  "children": [] }, ] }, { "name": "Problem Solving and Search", "size": 50, "children": [{ "name": "Uninformed Search Strategies", "size": 50, "children": [{ "name": "Further Topics", "size": 50, "children": [{ "name": "duplicate pruning", "size": 50,  "children": [] }, { "name": "graph search", "size": 50,  "children": [] }, { "name": "search algorithm", "size": 50, "color": "lightred",  "children": [] }, ] }, { "name": "Breadth-First Search Strategies", "size": 50, "children": [{ "name": "UCS", "size": 50,  "children": [] }, { "name": "BFS", "size": 50,  "children": [] }, ] }, { "name": "Depth-First Search Strategies", "size": 50, "children": [{ "name": "depth limited search", "size": 50,  "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "IDS", "size": 50,  "children": [] }, { "name": "depth limit", "size": 50,  "children": [] }, { "name": "DFS", "size": 50,  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, ] }, { "name": "depth limited search", "size": 50,  "children": [] }, { "name": "uninformed", "size": 50,  "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "DFS", "size": 50,  "children": [] }, { "name": "duplicate pruning", "size": 50,  "children": [] }, { "name": "graph search", "size": 50,  "children": [] }, { "name": "IDS", "size": 50,  "children": [] }, { "name": "search algorithm", "size": 50, "color": "lightred",  "children": [] }, { "name": "BFS", "size": 50,  "children": [] }, { "name": "depth limit", "size": 50,  "children": [] }, { "name": "UCS", "size": 50,  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, ] }, { "name": "Informed Search Strategies", "size": 50, "children": [{ "name": "Greedy Search", "size": 50, "children": [{ "name": "heuristic search", "size": 50,  "children": [] }, { "name": "greedy search", "size": 50,  "children": [] }, { "name": "desirability", "size": 50,  "children": [] }, { "name": "heuristic", "size": 50,  "children": [] }, { "name": "SLDheuristic", "size": 50,  "children": [] }, { "name": "best first search", "size": 50,  "children": [] }, { "name": "evaluation function", "size": 50,  "children": [] }, ] }, { "name": "Heuristics and their Properties", "size": 50, "children": [{ "name": "heuristic", "size": 50,  "children": [] }, { "name": "admissible", "size": 50,  "children": [] }, { "name": "real cost", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, ] }, { "name": "A-Star Search", "size": 50, "children": [{ "name": "evaluation function", "size": 50,  "children": [] }, { "name": "astar search", "size": 50,  "children": [] }, ] }, { "name": "Finding Good Heuristics", "size": 50, "children": [{ "name": "manhattendist", "size": 50,  "children": [] }, { "name": "misplacedtiles", "size": 50,  "children": [] }, { "name": "dominate", "size": 50,  "children": [] }, { "name": "relax", "size": 50,  "children": [] }, ] }, { "name": "heuristic search", "size": 50,  "children": [] }, { "name": "relax", "size": 50,  "children": [] }, { "name": "dominate", "size": 50,  "children": [] }, { "name": "astar search", "size": 50,  "children": [] }, { "name": "best first search", "size": 50,  "children": [] }, { "name": "desirability", "size": 50,  "children": [] }, { "name": "heuristic", "size": 50,  "children": [] }, { "name": "manhattendist", "size": 50,  "children": [] }, { "name": "SLDheuristic", "size": 50,  "children": [] }, { "name": "misplacedtiles", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "evaluation function", "size": 50,  "children": [] }, { "name": "greedy search", "size": 50,  "children": [] }, { "name": "real cost", "size": 50,  "children": [] }, { "name": "admissible", "size": 50,  "children": [] }, { "name": "informed", "size": 50,  "children": [] }, ] }, { "name": "Problem Types", "size": 50, "children": [{ "name": "multi state problem", "size": 50,  "children": [] }, { "name": "single state problem", "size": 50,  "children": [] }, { "name": "contingency problem", "size": 50,  "children": [] }, ] }, { "name": "Local Search", "size": 50, "children": [{ "name": "local beam search", "size": 50,  "children": [] }, { "name": "systematic", "size": 50,  "children": [] }, { "name": "crossover", "size": 50,  "children": [] }, { "name": "genetic algorithm", "size": 50,  "children": [] }, { "name": "simulated annealing", "size": 50,  "children": [] }, { "name": "mutation", "size": 50,  "children": [] }, { "name": "schedule", "size": 50,  "children": [] }, { "name": "Ridge", "size": 50,  "children": [] }, { "name": "TSP", "size": 50,  "children": [] }, { "name": "local search algorithm", "size": 50,  "children": [] }, { "name": "nqueens", "size": 50,  "children": [] }, { "name": "hill climbing", "size": 50,  "children": [] }, { "name": "current state", "size": 50,  "children": [] }, ] }, { "name": "Problem Solving", "size": 50, "children": [{ "name": "goal test", "size": 50,  "children": [] }, { "name": "actions", "size": 50, "color": "lightred",  "children": [] }, { "name": "goal state", "size": 50, "color": "red",  "children": [] }, { "name": "initial state", "size": 50, "color": "red",  "children": [] }, { "name": "cost", "size": 50,  "children": [] }, { "name": "offline", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "result relation", "size": 50,  "children": [] }, { "name": "declarative description", "size": 50,  "children": [] }, { "name": "online", "size": 50,  "children": [] }, { "name": "successor states", "size": 50, "color": "lightred",  "children": [] }, { "name": "step cost", "size": 50,  "children": [] }, { "name": "problem formulation", "size": 50,  "children": [] }, { "name": "deterministic", "size": 50,  "children": [] }, { "name": "solution", "size": 50, "color": "lightred",  "children": [] }, { "name": "problem description language", "size": 50,  "children": [] }, { "name": "state space", "size": 50, "color": "lightred",  "children": [] }, { "name": "successor function", "size": 50,  "children": [] }, { "name": "transition model", "size": 50, "color": "red",  "children": [] }, { "name": "successor state", "size": 50,  "children": [] }, { "name": "applicable", "size": 50,  "children": [] }, { "name": "states", "size": 50, "color": "lightred",  "children": [] }, { "name": "cost function", "size": 50,  "children": [] }, { "name": "problem solving", "size": 50,  "children": [] }, { "name": "search problem", "size": 50, "color": "red",  "children": [] }, { "name": "blackbox description", "size": 50,  "children": [] }, ] }, { "name": "Search", "size": 50, "children": [{ "name": "expand", "size": 50, "color": "lightred",  "children": [] }, { "name": "strategy", "size": 50, "color": "red",  "children": [] }, { "name": "tree search algorithm", "size": 50,  "children": [] }, { "name": "goal node", "size": 50,  "children": [] }, { "name": "path cost", "size": 50,  "children": [] }, { "name": "search tree", "size": 50, "color": "lightred",  "children": [] }, { "name": "fringe", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "tree search algorithm", "size": 50,  "children": [] }, { "name": "goal node", "size": 50,  "children": [] }, { "name": "contingency problem", "size": 50,  "children": [] }, { "name": "relax", "size": 50,  "children": [] }, { "name": "cost", "size": 50,  "children": [] }, { "name": "offline", "size": 50,  "children": [] }, { "name": "simulated annealing", "size": 50,  "children": [] }, { "name": "Ridge", "size": 50,  "children": [] }, { "name": "graph search", "size": 50,  "children": [] }, { "name": "declarative description", "size": 50,  "children": [] }, { "name": "step cost", "size": 50,  "children": [] }, { "name": "current state", "size": 50,  "children": [] }, { "name": "successor states", "size": 50, "color": "lightred",  "children": [] }, { "name": "local beam search", "size": 50,  "children": [] }, { "name": "solution", "size": 50, "color": "lightred",  "children": [] }, { "name": "problem description language", "size": 50,  "children": [] }, { "name": "systematic", "size": 50,  "children": [] }, { "name": "successor function", "size": 50,  "children": [] }, { "name": "duplicate pruning", "size": 50,  "children": [] }, { "name": "greedy search", "size": 50,  "children": [] }, { "name": "search algorithm", "size": 50, "color": "lightred",  "children": [] }, { "name": "nqueens", "size": 50,  "children": [] }, { "name": "depth limited search", "size": 50,  "children": [] }, { "name": "heuristic search", "size": 50,  "children": [] }, { "name": "actions", "size": 50, "color": "lightred",  "children": [] }, { "name": "goal state", "size": 50, "color": "red",  "children": [] }, { "name": "genetic algorithm", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "best first search", "size": 50,  "children": [] }, { "name": "multi state problem", "size": 50,  "children": [] }, { "name": "successor state", "size": 50,  "children": [] }, { "name": "real cost", "size": 50,  "children": [] }, { "name": "blackbox description", "size": 50,  "children": [] }, { "name": "astar search", "size": 50,  "children": [] }, { "name": "mutation", "size": 50,  "children": [] }, { "name": "dominate", "size": 50,  "children": [] }, { "name": "depth limit", "size": 50,  "children": [] }, { "name": "single state problem", "size": 50,  "children": [] }, { "name": "search tree", "size": 50, "color": "lightred",  "children": [] }, { "name": "online", "size": 50,  "children": [] }, { "name": "uninformed", "size": 50,  "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "desirability", "size": 50,  "children": [] }, { "name": "SLDheuristic", "size": 50,  "children": [] }, { "name": "manhattendist", "size": 50,  "children": [] }, { "name": "misplacedtiles", "size": 50,  "children": [] }, { "name": "IDS", "size": 50,  "children": [] }, { "name": "strategy", "size": 50, "color": "red",  "children": [] }, { "name": "states", "size": 50, "color": "lightred",  "children": [] }, { "name": "UCS", "size": 50,  "children": [] }, { "name": "expand", "size": 50, "color": "lightred",  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, { "name": "goal test", "size": 50,  "children": [] }, { "name": "initial state", "size": 50, "color": "red",  "children": [] }, { "name": "crossover", "size": 50,  "children": [] }, { "name": "DFS", "size": 50,  "children": [] }, { "name": "local search algorithm", "size": 50,  "children": [] }, { "name": "BFS", "size": 50,  "children": [] }, { "name": "result relation", "size": 50,  "children": [] }, { "name": "hill climbing", "size": 50,  "children": [] }, { "name": "admissible", "size": 50,  "children": [] }, { "name": "problem formulation", "size": 50,  "children": [] }, { "name": "deterministic", "size": 50,  "children": [] }, { "name": "heuristic", "size": 50,  "children": [] }, { "name": "state space", "size": 50, "color": "lightred",  "children": [] }, { "name": "path cost", "size": 50,  "children": [] }, { "name": "schedule", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "transition model", "size": 50, "color": "red",  "children": [] }, { "name": "evaluation function", "size": 50,  "children": [] }, { "name": "applicable", "size": 50,  "children": [] }, { "name": "TSP", "size": 50,  "children": [] }, { "name": "cost function", "size": 50,  "children": [] }, { "name": "problem solving", "size": 50,  "children": [] }, { "name": "search problem", "size": 50, "color": "red",  "children": [] }, { "name": "fringe", "size": 50, "color": "red",  "children": [] }, { "name": "informed", "size": 50,  "children": [] }, ] }, { "name": "Constraint Propagation", "size": 50, "children": [{ "name": "Conclusion & Summary", "size": 50, "children": [] }, { "name": "Forward Checking", "size": 50, "children": [{ "name": "subsume", "size": 50,  "children": [] }, { "name": "forward checking", "size": 50,  "children": [] }, { "name": "sound", "size": 50,  "children": [] }, ] }, { "name": "Decomposition: Constraint Graphs, and Three Simple Cases", "size": 50, "children": [{ "name": "AcyclicCG", "size": 50,  "children": [] }, { "name": "decomposition", "size": 50,  "children": [] }, { "name": "independent subproblem", "size": 50,  "children": [] }, { "name": "cutset conditioning", "size": 50,  "children": [] }, { "name": "conditioning", "size": 50,  "children": [] }, ] }, { "name": "Constraint Propagation/Inference", "size": 50, "children": [{ "name": "equivalent", "size": 50,  "children": [] }, { "name": "strictly tighter", "size": 50,  "children": [] }, { "name": "tighter", "size": 50,  "children": [] }, { "name": "backtracking with inference", "size": 50,  "children": [] }, { "name": "constraint propagation", "size": 50,  "children": [] }, ] }, { "name": "Constraint Propagation with Local Search", "size": 50, "children": [{ "name": "min conflicts", "size": 50,  "children": [] }, ] }, { "name": "Introduction", "size": 50, "children": [] }, { "name": "Cutset Conditioning", "size": 50, "children": [{ "name": "cutset", "size": 50,  "children": [] }, { "name": "optimal", "size": 50,  "children": [] }, { "name": "cutset conditioning", "size": 50,  "children": [] }, ] }, { "name": "Arc Consistency", "size": 50, "children": [{ "name": "AC-1", "size": 50,  "children": [] }, { "name": "AC-3", "size": 50,  "children": [] }, { "name": "acn", "size": 50, "color": "lightred",  "children": [] }, { "name": "acv", "size": 50, "color": "lightred",  "children": [] }, { "name": "Revise", "size": 50,  "children": [] }, { "name": "arc consistency", "size": 50, "color": "orange",  "children": [] }, ] }, { "name": "optimal", "size": 50,  "children": [] }, { "name": "min conflicts", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "strictly tighter", "size": 50,  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "AC-1", "size": 50,  "children": [] }, { "name": "decomposition", "size": 50,  "children": [] }, { "name": "cutset", "size": 50,  "children": [] }, { "name": "independent subproblem", "size": 50,  "children": [] }, { "name": "forward checking", "size": 50,  "children": [] }, { "name": "conditioning", "size": 50,  "children": [] }, { "name": "cutset conditioning", "size": 50,  "children": [] }, { "name": "Revise", "size": 50,  "children": [] }, { "name": "tighter", "size": 50,  "children": [] }, { "name": "backtracking with inference", "size": 50,  "children": [] }, { "name": "constraint propagation", "size": 50,  "children": [] }, { "name": "arc consistency", "size": 50, "color": "orange",  "children": [] }, { "name": "AcyclicCG", "size": 50,  "children": [] }, { "name": "sound", "size": 50,  "children": [] }, { "name": "acn", "size": 50, "color": "lightred",  "children": [] }, { "name": "AC-3", "size": 50,  "children": [] }, { "name": "acv", "size": 50, "color": "lightred",  "children": [] }, ] }, { "name": "Adversarial Search for Game Playing", "size": 50, "children": [{ "name": "Minimax Search", "size": 50, "children": [{ "name": "minimax", "size": 50,  "children": [] }, { "name": "Max-node", "size": 50,  "children": [] }, { "name": "utility function", "size": 50,  "children": [] }, { "name": "Min-node", "size": 50,  "children": [] }, ] }, { "name": "Conclusion", "size": 50, "children": [] }, { "name": "State of the Art", "size": 50, "children": [] }, { "name": "Monte-Carlo Tree Search (MCTS)", "size": 50, "children": [{ "name": "MCTS", "size": 50,  "children": [] }, { "name": "MCTS tree", "size": 50,  "children": [] }, { "name": "SL policy network", "size": 50,  "children": [] }, { "name": "rollout policy", "size": 50,  "children": [] }, { "name": "RL policy network", "size": 50,  "children": [] }, { "name": "exploitation", "size": 50,  "children": [] }, { "name": "value network", "size": 50,  "children": [] }, { "name": "Monte Carlo sampling", "size": 50,  "children": [] }, { "name": "exploration", "size": 50,  "children": [] }, { "name": "UCT", "size": 50,  "children": [] }, { "name": "policy network", "size": 50,  "children": [] }, ] }, { "name": "Introduction", "size": 50, "children": [{ "name": "MaxPlayer", "size": 50,  "children": [] }, { "name": "goal state", "size": 50, "color": "red",  "children": [] }, { "name": "general game playing", "size": 50,  "children": [] }, { "name": "adversarial search problem", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "game utility function", "size": 50,  "children": [] }, { "name": "GDL", "size": 50,  "children": [] }, { "name": "adversarial search", "size": 50,  "children": [] }, { "name": "ai1game", "size": 50,  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "xactions", "size": 50,  "children": [] }, { "name": "strategyfor", "size": 50,  "children": [] }, { "name": "strategyforOp", "size": 50,  "children": [] }, { "name": "declarative", "size": 50,  "children": [] }, { "name": "blackbox", "size": 50,  "children": [] }, { "name": "solver", "size": 50,  "children": [] }, { "name": "explicit", "size": 50,  "children": [] }, { "name": "xstates", "size": 50,  "children": [] }, { "name": "optimal", "size": 50,  "children": [] }, { "name": "MinPlayer", "size": 50,  "children": [] }, { "name": "strategy", "size": 50,  "children": [] }, ] }, { "name": "Evaluation Functions", "size": 50, "children": [{ "name": "quiescent search", "size": 50,  "children": [] }, { "name": "unquiet", "size": 50,  "children": [] }, { "name": "horizon", "size": 50,  "children": [] }, { "name": "cut-off state", "size": 50,  "children": [] }, { "name": "evaluation function", "size": 50,  "children": [] }, { "name": "weighted linear function", "size": 50,  "children": [] }, { "name": "weight", "size": 50,  "children": [] }, ] }, { "name": "Alpha-Beta Search", "size": 50, "children": [{ "name": "alphabeta-pruning", "size": 50,  "children": [] }, { "name": "alpha value", "size": 50,  "children": [] }, { "name": "beta value", "size": 50,  "children": [] }, { "name": "alphabeta search", "size": 50,  "children": [] }, ] }, { "name": "MaxPlayer", "size": 50,  "children": [] }, { "name": "general game playing", "size": 50,  "children": [] }, { "name": "alphabeta search", "size": 50,  "children": [] }, { "name": "Min-node", "size": 50,  "children": [] }, { "name": "adversarial search problem", "size": 50,  "children": [] }, { "name": "GDL", "size": 50,  "children": [] }, { "name": "RL policy network", "size": 50,  "children": [] }, { "name": "exploitation", "size": 50,  "children": [] }, { "name": "cut-off state", "size": 50,  "children": [] }, { "name": "Max-node", "size": 50,  "children": [] }, { "name": "value network", "size": 50,  "children": [] }, { "name": "xactions", "size": 50,  "children": [] }, { "name": "rollout policy", "size": 50,  "children": [] }, { "name": "alphabeta-pruning", "size": 50,  "children": [] }, { "name": "declarative", "size": 50,  "children": [] }, { "name": "weight", "size": 50,  "children": [] }, { "name": "minimax", "size": 50,  "children": [] }, { "name": "horizon", "size": 50,  "children": [] }, { "name": "xstates", "size": 50,  "children": [] }, { "name": "strategy", "size": 50,  "children": [] }, { "name": "policy network", "size": 50,  "children": [] }, { "name": "beta value", "size": 50,  "children": [] }, { "name": "goal state", "size": 50, "color": "red",  "children": [] }, { "name": "unquiet", "size": 50,  "children": [] }, { "name": "SL policy network", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "game utility function", "size": 50,  "children": [] }, { "name": "utility function", "size": 50,  "children": [] }, { "name": "adversarial search", "size": 50,  "children": [] }, { "name": "ai1game", "size": 50,  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "Monte Carlo sampling", "size": 50,  "children": [] }, { "name": "alpha value", "size": 50,  "children": [] }, { "name": "exploration", "size": 50,  "children": [] }, { "name": "evaluation function", "size": 50,  "children": [] }, { "name": "MCTS tree", "size": 50,  "children": [] }, { "name": "MCTS", "size": 50,  "children": [] }, { "name": "strategyfor", "size": 50,  "children": [] }, { "name": "strategyforOp", "size": 50,  "children": [] }, { "name": "blackbox", "size": 50,  "children": [] }, { "name": "weighted linear function", "size": 50,  "children": [] }, { "name": "quiescent search", "size": 50,  "children": [] }, { "name": "solver", "size": 50,  "children": [] }, { "name": "explicit", "size": 50,  "children": [] }, { "name": "UCT", "size": 50,  "children": [] }, { "name": "optimal", "size": 50,  "children": [] }, { "name": "MinPlayer", "size": 50,  "children": [] }, ] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "tree search algorithm", "size": 50,  "children": [] }, { "name": "goal node", "size": 50,  "children": [] }, { "name": "unary", "size": 50,  "children": [] }, { "name": "relax", "size": 50,  "children": [] }, { "name": "cost", "size": 50,  "children": [] }, { "name": "offline", "size": 50,  "children": [] }, { "name": "Ridge", "size": 50,  "children": [] }, { "name": "declarative description", "size": 50,  "children": [] }, { "name": "redcolor", "size": 50,  "children": [] }, { "name": "solution", "size": 50,  "children": [] }, { "name": "current state", "size": 50,  "children": [] }, { "name": "successor states", "size": 50, "color": "lightred",  "children": [] }, { "name": "Revise", "size": 50,  "children": [] }, { "name": "local beam search", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "solution", "size": 50, "color": "lightred",  "children": [] }, { "name": "problem description language", "size": 50,  "children": [] }, { "name": "step cost", "size": 50,  "children": [] }, { "name": "conditioning", "size": 50,  "children": [] }, { "name": "constrained optimization problem", "size": 50,  "children": [] }, { "name": "alphabeta-pruning", "size": 50,  "children": [] }, { "name": "value ordering", "size": 50,  "children": [] }, { "name": "duplicate pruning", "size": 50,  "children": [] }, { "name": "greedy search", "size": 50,  "children": [] }, { "name": "search algorithm", "size": 50, "color": "lightred",  "children": [] }, { "name": "constraint graph", "size": 50, "color": "red",  "children": [] }, { "name": "Vvar", "size": 50,  "children": [] }, { "name": "depth limited search", "size": 50,  "children": [] }, { "name": "beta value", "size": 50,  "children": [] }, { "name": "SL policy network", "size": 50,  "children": [] }, { "name": "least constraining value", "size": 50,  "children": [] }, { "name": "action", "size": 50, "color": "orange",  "children": [] }, { "name": "utility function", "size": 50,  "children": [] }, { "name": "crypto-arithmetic puzzle", "size": 50,  "children": [] }, { "name": "domainof", "size": 50, "color": "red",  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "conflict", "size": 50,  "children": [] }, { "name": "binary CSP", "size": 50,  "children": [] }, { "name": "least constraining value heuristic", "size": 50,  "children": [] }, { "name": "alpha value", "size": 50,  "children": [] }, { "name": "MCTS tree", "size": 50,  "children": [] }, { "name": "independent subproblem", "size": 50,  "children": [] }, { "name": "cutset conditioning", "size": 50,  "children": [] }, { "name": "strategyfor", "size": 50,  "children": [] }, { "name": "multi state problem", "size": 50,  "children": [] }, { "name": "binary", "size": 50,  "children": [] }, { "name": "blackbox", "size": 50,  "children": [] }, { "name": "weighted linear function", "size": 50,  "children": [] }, { "name": "backtracking with inference", "size": 50,  "children": [] }, { "name": "successor state", "size": 50,  "children": [] }, { "name": "var", "size": 50,  "children": [] }, { "name": "real cost", "size": 50,  "children": [] }, { "name": "AC-3", "size": 50,  "children": [] }, { "name": "acv", "size": 50, "color": "lightred",  "children": [] }, { "name": "MinPlayer", "size": 50,  "children": [] }, { "name": "violate", "size": 50,  "children": [] }, { "name": "astar search", "size": 50,  "children": [] }, { "name": "min conflicts", "size": 50,  "children": [] }, { "name": "alphabeta search", "size": 50,  "children": [] }, { "name": "adversarial search problem", "size": 50,  "children": [] }, { "name": "bluecolor", "size": 50,  "children": [] }, { "name": "variable ordering", "size": 50,  "children": [] }, { "name": "dominate", "size": 50,  "children": [] }, { "name": "RL policy network", "size": 50,  "children": [] }, { "name": "cutset", "size": 50,  "children": [] }, { "name": "constraint network", "size": 50, "color": "lightred",  "children": [] }, { "name": "continuous", "size": 50,  "children": [] }, { "name": "depth limit", "size": 50,  "children": [] }, { "name": "single state problem", "size": 50,  "children": [] }, { "name": "search tree", "size": 50, "color": "lightred",  "children": [] }, { "name": "induced search problem", "size": 50,  "children": [] }, { "name": "weight", "size": 50,  "children": [] }, { "name": "satisfy", "size": 50,  "children": [] }, { "name": "arc consistency", "size": 50, "color": "orange",  "children": [] }, { "name": "domain", "size": 50, "color": "red",  "children": [] }, { "name": "IDS", "size": 50,  "children": [] }, { "name": "states", "size": 50, "color": "lightred",  "children": [] }, { "name": "horizon", "size": 50,  "children": [] }, { "name": "auxiliary variable", "size": 50,  "children": [] }, { "name": "xstates", "size": 50,  "children": [] }, { "name": "MRV", "size": 50,  "children": [] }, { "name": "expand", "size": 50, "color": "lightred",  "children": [] }, { "name": "policy network", "size": 50,  "children": [] }, { "name": "optimal", "size": 50,  "children": [] }, { "name": "unquiet", "size": 50,  "children": [] }, { "name": "AC-1", "size": 50,  "children": [] }, { "name": "initial state", "size": 50, "color": "red",  "children": [] }, { "name": "decomposition", "size": 50,  "children": [] }, { "name": "degree heuristic", "size": 50,  "children": [] }, { "name": "game utility function", "size": 50,  "children": [] }, { "name": "Tvar", "size": 50,  "children": [] }, { "name": "ai1game", "size": 50,  "children": [] }, { "name": "ternary", "size": 50,  "children": [] }, { "name": "exploration", "size": 50,  "children": [] }, { "name": "MCTS", "size": 50,  "children": [] }, { "name": "problem formulation", "size": 50,  "children": [] }, { "name": "strategyforOp", "size": 50,  "children": [] }, { "name": "domain", "size": 50, "color": "lightred",  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "state space", "size": 50, "color": "lightred",  "children": [] }, { "name": "heuristic", "size": 50,  "children": [] }, { "name": "path cost", "size": 50,  "children": [] }, { "name": "schedule", "size": 50,  "children": [] }, { "name": "Qvar", "size": 50,  "children": [] }, { "name": "quiescent search", "size": 50,  "children": [] }, { "name": "TSP", "size": 50,  "children": [] }, { "name": "explicit", "size": 50,  "children": [] }, { "name": "admissible", "size": 50,  "children": [] }, { "name": "search problem", "size": 50, "color": "red",  "children": [] }, { "name": "optimal", "size": 50,  "children": [] }, { "name": "informed", "size": 50,  "children": [] }, { "name": "UCT", "size": 50,  "children": [] }, { "name": "fringe", "size": 50, "color": "red",  "children": [] }, { "name": "legal", "size": 50,  "children": [] }, { "name": "contingency problem", "size": 50,  "children": [] }, { "name": "simulated annealing", "size": 50,  "children": [] }, { "name": "exploitation", "size": 50,  "children": [] }, { "name": "graph search", "size": 50,  "children": [] }, { "name": "cut-off state", "size": 50,  "children": [] }, { "name": "Max-node", "size": 50,  "children": [] }, { "name": "value network", "size": 50,  "children": [] }, { "name": "xactions", "size": 50,  "children": [] }, { "name": "systematic", "size": 50,  "children": [] }, { "name": "SAvar", "size": 50,  "children": [] }, { "name": "rollout policy", "size": 50,  "children": [] }, { "name": "declarative", "size": 50,  "children": [] }, { "name": "successor function", "size": 50,  "children": [] }, { "name": "constraint propagation", "size": 50,  "children": [] }, { "name": "minimax", "size": 50,  "children": [] }, { "name": "nqueens", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "strategy", "size": 50,  "children": [] }, { "name": "extend", "size": 50,  "children": [] }, { "name": "heuristic search", "size": 50,  "children": [] }, { "name": "actions", "size": 50, "color": "lightred",  "children": [] }, { "name": "goal state", "size": 50, "color": "red",  "children": [] }, { "name": "preference", "size": 50,  "children": [] }, { "name": "genetic algorithm", "size": 50,  "children": [] }, { "name": "adversarial search", "size": 50,  "children": [] }, { "name": "best first search", "size": 50,  "children": [] }, { "name": "map coloring", "size": 50,  "children": [] }, { "name": "higher-order", "size": 50,  "children": [] }, { "name": "tighter", "size": 50,  "children": [] }, { "name": "solve", "size": 50,  "children": [] }, { "name": "constraint solving", "size": 50,  "children": [] }, { "name": "most constraining", "size": 50,  "children": [] }, { "name": "solver", "size": 50,  "children": [] }, { "name": "CSP", "size": 50, "color": "red",  "children": [] }, { "name": "blackbox description", "size": 50,  "children": [] }, { "name": "discrete", "size": 50,  "children": [] }, { "name": "unary constraint", "size": 50,  "children": [] }, { "name": "MaxPlayer", "size": 50,  "children": [] }, { "name": "strictly tighter", "size": 50,  "children": [] }, { "name": "general game playing", "size": 50,  "children": [] }, { "name": "Min-node", "size": 50,  "children": [] }, { "name": "mutation", "size": 50,  "children": [] }, { "name": "GDL", "size": 50,  "children": [] }, { "name": "order", "size": 50,  "children": [] }, { "name": "NSWvar", "size": 50,  "children": [] }, { "name": "forward checking", "size": 50,  "children": [] }, { "name": "online", "size": 50,  "children": [] }, { "name": "uninformed", "size": 50,  "children": [] }, { "name": "backtrack", "size": 50,  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "desirability", "size": 50,  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "SLDheuristic", "size": 50,  "children": [] }, { "name": "manhattendist", "size": 50,  "children": [] }, { "name": "misplacedtiles", "size": 50,  "children": [] }, { "name": "strategy", "size": 50, "color": "red",  "children": [] }, { "name": "constraint", "size": 50, "color": "lightred",  "children": [] }, { "name": "sound", "size": 50,  "children": [] }, { "name": "acn", "size": 50, "color": "lightred",  "children": [] }, { "name": "UCS", "size": 50,  "children": [] }, { "name": "backtrack point", "size": 50,  "children": [] }, { "name": "goal test", "size": 50,  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "crossover", "size": 50,  "children": [] }, { "name": "backtracking search", "size": 50,  "children": [] }, { "name": "DFS", "size": 50,  "children": [] }, { "name": "greencolor", "size": 50,  "children": [] }, { "name": "local search algorithm", "size": 50,  "children": [] }, { "name": "BFS", "size": 50,  "children": [] }, { "name": "result relation", "size": 50,  "children": [] }, { "name": "hill climbing", "size": 50,  "children": [] }, { "name": "variable", "size": 50, "color": "lightred",  "children": [] }, { "name": "evaluation function", "size": 50,  "children": [] }, { "name": "NTvar", "size": 50,  "children": [] }, { "name": "WAvar", "size": 50,  "children": [] }, { "name": "deterministic", "size": 50,  "children": [] }, { "name": "constraint", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "transition model", "size": 50, "color": "red",  "children": [] }, { "name": "evaluation function", "size": 50,  "children": [] }, { "name": "applicable", "size": 50,  "children": [] }, { "name": "cost function", "size": 50,  "children": [] }, { "name": "Monte Carlo sampling", "size": 50,  "children": [] }, { "name": "problem solving", "size": 50,  "children": [] }, { "name": "AcyclicCG", "size": 50,  "children": [] }, ] }, { "name": "Knowledge and Inference", "size": 50, "children": [{ "name": "Excursions", "size": 50, "children": [{ "name": "Completeness of Calculi for Propositional Logic", "size": 50, "children": [{ "name": "Abstract Consistency and Model Existence", "size": 50, "children": [{ "name": "reasonable", "size": 50,  "children": [] }, { "name": "absstar", "size": 50,  "children": [] }, { "name": "absc", "size": 50,  "children": [] }, { "name": "refute", "size": 50,  "children": [] }, { "name": "hintneg", "size": 50,  "children": [] }, { "name": "hintor", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "sunion", "size": 50,  "children": [] }, { "name": "compact", "size": 50,  "children": [] }, { "name": "hintstar", "size": 50,  "children": [] }, { "name": "closed under subsets", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "absneg", "size": 50,  "children": [] }, { "name": "absor", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "refutable", "size": 50,  "children": [] }, { "name": "hintc", "size": 50,  "children": [] }, { "name": "absand", "size": 50,  "children": [] }, { "name": "HintikkaSet", "size": 50,  "children": [] }, { "name": "hintand", "size": 50,  "children": [] }, { "name": "contradiction", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, ] }, { "name": "A Completeness Proof for Propositional Tableaux", "size": 50, "children": [] }, { "name": "reasonable", "size": 50,  "children": [] }, { "name": "absstar", "size": 50,  "children": [] }, { "name": "absc", "size": 50,  "children": [] }, { "name": "refute", "size": 50,  "children": [] }, { "name": "hintneg", "size": 50,  "children": [] }, { "name": "hintor", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "sunion", "size": 50,  "children": [] }, { "name": "compact", "size": 50,  "children": [] }, { "name": "hintstar", "size": 50,  "children": [] }, { "name": "closed under subsets", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "absneg", "size": 50,  "children": [] }, { "name": "absor", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "refutable", "size": 50,  "children": [] }, { "name": "hintc", "size": 50,  "children": [] }, { "name": "absand", "size": 50,  "children": [] }, { "name": "HintikkaSet", "size": 50,  "children": [] }, { "name": "hintand", "size": 50,  "children": [] }, { "name": "contradiction", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, ] }, { "name": "reasonable", "size": 50,  "children": [] }, { "name": "absstar", "size": 50,  "children": [] }, { "name": "absc", "size": 50,  "children": [] }, { "name": "refute", "size": 50,  "children": [] }, { "name": "hintneg", "size": 50,  "children": [] }, { "name": "hintor", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "sunion", "size": 50,  "children": [] }, { "name": "compact", "size": 50,  "children": [] }, { "name": "hintstar", "size": 50,  "children": [] }, { "name": "closed under subsets", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "absneg", "size": 50,  "children": [] }, { "name": "absor", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "refutable", "size": 50,  "children": [] }, { "name": "hintc", "size": 50,  "children": [] }, { "name": "absand", "size": 50,  "children": [] }, { "name": "HintikkaSet", "size": 50,  "children": [] }, { "name": "hintand", "size": 50,  "children": [] }, { "name": "contradiction", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, ] }, { "name": "Knowledge Representation and the Semantic Web", "size": 50, "children": [{ "name": "Introduction to Knowledge Representation", "size": 50, "children": [{ "name": "Semantic Networks", "size": 50, "children": [{ "name": "terminology", "size": 50,  "children": [] }, { "name": "funcarg", "size": 50,  "children": [] }, { "name": "object", "size": 50, "color": "red",  "children": [] }, { "name": "derive", "size": 50,  "children": [] }, { "name": "isa link", "size": 50,  "children": [] }, { "name": "relation", "size": 50, "color": "red",  "children": [] }, { "name": "assertions", "size": 50,  "children": [] }, { "name": "inference", "size": 50, "color": "red",  "children": [] }, { "name": "semantic network", "size": 50,  "children": [] }, { "name": "inst link", "size": 50,  "children": [] }, { "name": "implicit", "size": 50,  "children": [] }, { "name": "link", "size": 50,  "children": [] }, { "name": "concept", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Knowledge & Representation", "size": 50, "children": [{ "name": "reasoning efficiency", "size": 50,  "children": [] }, { "name": "expressive adequacy", "size": 50,  "children": [] }, { "name": "evaluation criteria", "size": 50,  "children": [] }, { "name": "primitives", "size": 50,  "children": [] }, { "name": "meta representation", "size": 50,  "children": [] }, { "name": "completeness", "size": 50,  "children": [] }, ] }, { "name": "Other Knowledge Representation Approaches", "size": 50, "children": [{ "name": "frame", "size": 50,  "children": [] }, { "name": "script", "size": 50,  "children": [] }, ] }, { "name": "The Semantic Web", "size": 50, "children": [{ "name": "inference", "size": 50, "color": "red",  "children": [] }, { "name": "semantic web", "size": 50,  "children": [] }, ] }, { "name": "terminology", "size": 50,  "children": [] }, { "name": "object", "size": 50, "color": "red",  "children": [] }, { "name": "derive", "size": 50,  "children": [] }, { "name": "evaluation criteria", "size": 50,  "children": [] }, { "name": "frame", "size": 50,  "children": [] }, { "name": "primitives", "size": 50,  "children": [] }, { "name": "completeness", "size": 50,  "children": [] }, { "name": "semantic network", "size": 50,  "children": [] }, { "name": "reasoning efficiency", "size": 50,  "children": [] }, { "name": "inst link", "size": 50,  "children": [] }, { "name": "concept", "size": 50, "color": "red",  "children": [] }, { "name": "link", "size": 50,  "children": [] }, { "name": "funcarg", "size": 50,  "children": [] }, { "name": "isa link", "size": 50,  "children": [] }, { "name": "meta representation", "size": 50,  "children": [] }, { "name": "expressive adequacy", "size": 50,  "children": [] }, { "name": "relation", "size": 50, "color": "red",  "children": [] }, { "name": "assertions", "size": 50,  "children": [] }, { "name": "semantic web", "size": 50,  "children": [] }, { "name": "inference", "size": 50, "color": "red",  "children": [] }, { "name": "implicit", "size": 50,  "children": [] }, { "name": "script", "size": 50,  "children": [] }, ] }, { "name": "Description Logics and the Semantic Web", "size": 50, "children": [{ "name": "RDFalanguage", "size": 50,  "children": [] }, { "name": "object", "size": 50,  "children": [] }, { "name": "RDF graph", "size": 50,  "children": [] }, { "name": "triple", "size": 50,  "children": [] }, { "name": "subject", "size": 50,  "children": [] }, { "name": "resource", "size": 50,  "children": [] }, { "name": "SPARQL", "size": 50,  "children": [] }, { "name": "property value", "size": 50,  "children": [] }, { "name": "triplestore", "size": 50,  "children": [] }, { "name": "ontology web language", "size": 50,  "children": [] }, { "name": "RDF", "size": 50,  "children": [] }, { "name": "functional syntax", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "DL reasoner", "size": 50,  "children": [] }, { "name": "SPARQL endpoint", "size": 50,  "children": [] }, { "name": "property", "size": 50,  "children": [] }, ] }, { "name": "A simple Description Logic: ALC", "size": 50, "children": [{ "name": "Basic ALC: Concepts, Roles, and Quantification", "size": 50, "children": [{ "name": "top concept", "size": 50,  "children": [] }, { "name": "normalized", "size": 50,  "children": [] }, { "name": "role assertion", "size": 50,  "children": [] }, { "name": "ALCInter", "size": 50,  "children": [] }, { "name": "bottom concept", "size": 50,  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "role", "size": 50,  "children": [] }, { "name": "definiendum", "size": 50,  "children": [] }, { "name": "alc semantics", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "normalization", "size": 50,  "children": [] }, { "name": "ALT", "size": 50,  "children": [] }, { "name": "assertion", "size": 50,  "children": [] }, { "name": "ALCforall", "size": 50,  "children": [] }, { "name": "ALCexists", "size": 50,  "children": [] }, { "name": "primitive", "size": 50,  "children": [] }, { "name": "domain of discourse", "size": 50,  "children": [] }, { "name": "concept definition", "size": 50,  "children": [] }, { "name": "ALCFormulae", "size": 50,  "children": [] }, { "name": "definiens", "size": 50,  "children": [] }, { "name": "ALCsatisfies", "size": 50,  "children": [] }, { "name": "NNF", "size": 50,  "children": [] }, { "name": "ALC", "size": 50,  "children": [] }, { "name": "ABoxInd", "size": 50,  "children": [] }, { "name": "instance assertion", "size": 50,  "children": [] }, ] }, { "name": "Inference for ALC", "size": 50, "children": [{ "name": "ALCTcutRule", "size": 50,  "children": [] }, { "name": "ALCTexistsRule", "size": 50,  "children": [] }, { "name": "ALCTunionRule", "size": 50,  "children": [] }, { "name": "ALCTforallRule", "size": 50,  "children": [] }, { "name": "ALCT functional", "size": 50,  "children": [] }, { "name": "ALCTintersRule", "size": 50,  "children": [] }, { "name": "ALCTclosed", "size": 50,  "children": [] }, { "name": "ALCTcaxRule", "size": 50,  "children": [] }, { "name": "ALCT", "size": 50,  "children": [] }, ] }, { "name": "ABoxes, Instance Testing, and ALC", "size": 50, "children": [{ "name": "realization", "size": 50,  "children": [] }, { "name": "instance test", "size": 50,  "children": [] }, ] }, { "name": "ALCTcutRule", "size": 50,  "children": [] }, { "name": "bottom concept", "size": 50,  "children": [] }, { "name": "ALCT functional", "size": 50,  "children": [] }, { "name": "ALCTintersRule", "size": 50,  "children": [] }, { "name": "instance test", "size": 50,  "children": [] }, { "name": "role", "size": 50,  "children": [] }, { "name": "definiendum", "size": 50,  "children": [] }, { "name": "ALCexists", "size": 50,  "children": [] }, { "name": "domain of discourse", "size": 50,  "children": [] }, { "name": "realization", "size": 50,  "children": [] }, { "name": "definiens", "size": 50,  "children": [] }, { "name": "ALCsatisfies", "size": 50,  "children": [] }, { "name": "NNF", "size": 50,  "children": [] }, { "name": "ALC", "size": 50,  "children": [] }, { "name": "instance assertion", "size": 50,  "children": [] }, { "name": "ALCTexistsRule", "size": 50,  "children": [] }, { "name": "top concept", "size": 50,  "children": [] }, { "name": "normalized", "size": 50,  "children": [] }, { "name": "ALCTunionRule", "size": 50,  "children": [] }, { "name": "role assertion", "size": 50,  "children": [] }, { "name": "ALCInter", "size": 50,  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "alc semantics", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "ALCTcaxRule", "size": 50,  "children": [] }, { "name": "normalization", "size": 50,  "children": [] }, { "name": "ALCT", "size": 50,  "children": [] }, { "name": "ALT", "size": 50,  "children": [] }, { "name": "assertion", "size": 50,  "children": [] }, { "name": "ALCforall", "size": 50,  "children": [] }, { "name": "primitive", "size": 50,  "children": [] }, { "name": "ALCTforallRule", "size": 50,  "children": [] }, { "name": "concept definition", "size": 50,  "children": [] }, { "name": "ALCFormulae", "size": 50,  "children": [] }, { "name": "ALCTclosed", "size": 50,  "children": [] }, { "name": "ABoxInd", "size": 50,  "children": [] }, ] }, { "name": "Logic-Based Knowledge Representation", "size": 50, "children": [{ "name": "Description Logics and Inference", "size": 50, "children": [{ "name": "ontology system", "size": 50,  "children": [] }, { "name": "subsumption test", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "classification", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "consistency test", "size": 50,  "children": [] }, { "name": "instance test", "size": 50,  "children": [] }, ] }, { "name": "Propositional Logic as a Set Description Language", "size": 50, "children": [{ "name": "top concept", "size": 50,  "children": [] }, { "name": "complement", "size": 50,  "children": [] }, { "name": "bottom concept", "size": 50,  "children": [] }, { "name": "true", "size": 50,  "children": [] }, { "name": "union", "size": 50,  "children": [] }, { "name": "PropDL", "size": 50,  "children": [] }, { "name": "PLF", "size": 50,  "children": [] }, { "name": "concept", "size": 50, "color": "red",  "children": [] }, { "name": "krInter", "size": 50,  "children": [] }, { "name": "krConcept", "size": 50,  "children": [] }, { "name": "intersection", "size": 50,  "children": [] }, { "name": "domain of discourse", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "domaincomplement", "size": 50,  "children": [] }, { "name": "equivalence", "size": 50,  "children": [] }, { "name": "concept axiom", "size": 50, "color": "red",  "children": [] }, { "name": "PLT", "size": 50,  "children": [] }, ] }, { "name": "Ontologies and Description Logics", "size": 50, "children": [{ "name": "concept axiom", "size": 50, "color": "red",  "children": [] }, { "name": "normalized", "size": 50,  "children": [] }, { "name": "acyclic", "size": 50,  "children": [] }, { "name": "dl ontology", "size": 50,  "children": [] }, { "name": "TBox", "size": 50,  "children": [] }, { "name": "instance", "size": 50,  "children": [] }, { "name": "description logic", "size": 50,  "children": [] }, { "name": "role", "size": 50,  "children": [] }, { "name": "classical ontology", "size": 50,  "children": [] }, { "name": "concept", "size": 50, "color": "red",  "children": [] }, { "name": "dlcdef", "size": 50,  "children": [] }, { "name": "recursive", "size": 50,  "children": [] }, { "name": "relation", "size": 50, "color": "red",  "children": [] }, { "name": "concept definition", "size": 50,  "children": [] }, { "name": "ontology", "size": 50, "color": "red",  "children": [] }, { "name": "ABox", "size": 50,  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "TBox", "size": 50,  "children": [] }, { "name": "instance", "size": 50,  "children": [] }, { "name": "complement", "size": 50,  "children": [] }, { "name": "bottom concept", "size": 50,  "children": [] }, { "name": "instance test", "size": 50,  "children": [] }, { "name": "description logic", "size": 50,  "children": [] }, { "name": "role", "size": 50,  "children": [] }, { "name": "classical ontology", "size": 50,  "children": [] }, { "name": "concept", "size": 50, "color": "red",  "children": [] }, { "name": "krInter", "size": 50,  "children": [] }, { "name": "intersection", "size": 50,  "children": [] }, { "name": "domain of discourse", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "concept axiom", "size": 50, "color": "red",  "children": [] }, { "name": "PLT", "size": 50,  "children": [] }, { "name": "ABox", "size": 50,  "children": [] }, { "name": "union", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "top concept", "size": 50,  "children": [] }, { "name": "acyclic", "size": 50,  "children": [] }, { "name": "ontology system", "size": 50,  "children": [] }, { "name": "normalized", "size": 50,  "children": [] }, { "name": "dl ontology", "size": 50,  "children": [] }, { "name": "true", "size": 50,  "children": [] }, { "name": "PLF", "size": 50,  "children": [] }, { "name": "dlcdef", "size": 50,  "children": [] }, { "name": "recursive", "size": 50,  "children": [] }, { "name": "krConcept", "size": 50,  "children": [] }, { "name": "classification", "size": 50,  "children": [] }, { "name": "concept definition", "size": 50,  "children": [] }, { "name": "relation", "size": 50, "color": "red",  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "domaincomplement", "size": 50,  "children": [] }, { "name": "ontology", "size": 50, "color": "red",  "children": [] }, { "name": "equivalence", "size": 50,  "children": [] }, { "name": "PropDL", "size": 50,  "children": [] }, { "name": "subsumption test", "size": 50,  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "consistency test", "size": 50,  "children": [] }, ] }, { "name": "RDFalanguage", "size": 50,  "children": [] }, { "name": "TBox", "size": 50,  "children": [] }, { "name": "evaluation criteria", "size": 50,  "children": [] }, { "name": "ALCTintersRule", "size": 50,  "children": [] }, { "name": "bottom concept", "size": 50,  "children": [] }, { "name": "completeness", "size": 50,  "children": [] }, { "name": "complement", "size": 50,  "children": [] }, { "name": "semantic network", "size": 50,  "children": [] }, { "name": "role", "size": 50,  "children": [] }, { "name": "definiendum", "size": 50,  "children": [] }, { "name": "resource", "size": 50,  "children": [] }, { "name": "link", "size": 50,  "children": [] }, { "name": "krInter", "size": 50,  "children": [] }, { "name": "isa link", "size": 50,  "children": [] }, { "name": "realization", "size": 50,  "children": [] }, { "name": "semantic web", "size": 50,  "children": [] }, { "name": "inference", "size": 50, "color": "red",  "children": [] }, { "name": "definiens", "size": 50,  "children": [] }, { "name": "ALC", "size": 50,  "children": [] }, { "name": "ABox", "size": 50,  "children": [] }, { "name": "union", "size": 50,  "children": [] }, { "name": "meta representation", "size": 50,  "children": [] }, { "name": "ALCTunionRule", "size": 50,  "children": [] }, { "name": "ontology system", "size": 50,  "children": [] }, { "name": "object", "size": 50, "color": "red",  "children": [] }, { "name": "acyclic", "size": 50,  "children": [] }, { "name": "ALCInter", "size": 50,  "children": [] }, { "name": "frame", "size": 50,  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "reasoning efficiency", "size": 50,  "children": [] }, { "name": "ALCTcaxRule", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "SPARQL", "size": 50,  "children": [] }, { "name": "PLF", "size": 50,  "children": [] }, { "name": "property value", "size": 50,  "children": [] }, { "name": "assertion", "size": 50,  "children": [] }, { "name": "funcarg", "size": 50,  "children": [] }, { "name": "recursive", "size": 50,  "children": [] }, { "name": "ontology web language", "size": 50,  "children": [] }, { "name": "RDF", "size": 50,  "children": [] }, { "name": "concept definition", "size": 50,  "children": [] }, { "name": "ALCTforallRule", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "domaincomplement", "size": 50,  "children": [] }, { "name": "implicit", "size": 50,  "children": [] }, { "name": "DL reasoner", "size": 50,  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "property", "size": 50,  "children": [] }, { "name": "terminology", "size": 50,  "children": [] }, { "name": "ALCTcutRule", "size": 50,  "children": [] }, { "name": "derive", "size": 50,  "children": [] }, { "name": "instance", "size": 50,  "children": [] }, { "name": "ALCT functional", "size": 50,  "children": [] }, { "name": "instance test", "size": 50,  "children": [] }, { "name": "description logic", "size": 50,  "children": [] }, { "name": "triple", "size": 50,  "children": [] }, { "name": "PropDL", "size": 50,  "children": [] }, { "name": "subject", "size": 50,  "children": [] }, { "name": "classical ontology", "size": 50,  "children": [] }, { "name": "concept", "size": 50, "color": "red",  "children": [] }, { "name": "ALCexists", "size": 50,  "children": [] }, { "name": "intersection", "size": 50,  "children": [] }, { "name": "functional syntax", "size": 50,  "children": [] }, { "name": "domain of discourse", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "ALCsatisfies", "size": 50,  "children": [] }, { "name": "NNF", "size": 50,  "children": [] }, { "name": "concept axiom", "size": 50, "color": "red",  "children": [] }, { "name": "PLT", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "instance assertion", "size": 50,  "children": [] }, { "name": "script", "size": 50,  "children": [] }, { "name": "RDF graph", "size": 50,  "children": [] }, { "name": "ALCTexistsRule", "size": 50,  "children": [] }, { "name": "top concept", "size": 50,  "children": [] }, { "name": "normalized", "size": 50,  "children": [] }, { "name": "object", "size": 50,  "children": [] }, { "name": "role assertion", "size": 50,  "children": [] }, { "name": "dl ontology", "size": 50,  "children": [] }, { "name": "primitives", "size": 50,  "children": [] }, { "name": "true", "size": 50,  "children": [] }, { "name": "inst link", "size": 50,  "children": [] }, { "name": "alc semantics", "size": 50,  "children": [] }, { "name": "ALCT", "size": 50,  "children": [] }, { "name": "normalization", "size": 50,  "children": [] }, { "name": "ALT", "size": 50,  "children": [] }, { "name": "triplestore", "size": 50,  "children": [] }, { "name": "dlcdef", "size": 50,  "children": [] }, { "name": "krConcept", "size": 50,  "children": [] }, { "name": "expressive adequacy", "size": 50,  "children": [] }, { "name": "relation", "size": 50, "color": "red",  "children": [] }, { "name": "classification", "size": 50,  "children": [] }, { "name": "ALCforall", "size": 50,  "children": [] }, { "name": "primitive", "size": 50,  "children": [] }, { "name": "assertions", "size": 50,  "children": [] }, { "name": "ALCFormulae", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "ALCTclosed", "size": 50,  "children": [] }, { "name": "subsumption test", "size": 50,  "children": [] }, { "name": "equivalence", "size": 50,  "children": [] }, { "name": "ABoxInd", "size": 50,  "children": [] }, { "name": "ontology", "size": 50, "color": "red",  "children": [] }, { "name": "SPARQL endpoint", "size": 50,  "children": [] }, { "name": "consistency test", "size": 50,  "children": [] }, ] }, { "name": "Automated Theorem Proving in First-Order Logic", "size": 50, "children": [{ "name": "First-Order Inference with Tableaux", "size": 50, "children": [{ "name": "Efficient Unification", "size": 50, "children": [{ "name": "nodelabel", "size": 50,  "children": [] }, { "name": "termweight", "size": 50,  "children": [] }, { "name": "FOUDagevar", "size": 50,  "children": [] }, { "name": "FOUDagmerge", "size": 50,  "children": [] }, { "name": "DAG solved form", "size": 50,  "children": [] }, { "name": "FOUDagCalc", "size": 50,  "children": [] }, ] }, { "name": "First-Order Unification", "size": 50, "children": [{ "name": "pair", "size": 50,  "children": [] }, { "name": "sbstInstOr", "size": 50,  "children": [] }, { "name": "solved pair", "size": 50,  "children": [] }, { "name": "solved variable", "size": 50,  "children": [] }, { "name": "mgu", "size": 50,  "children": [] }, { "name": "unitary", "size": 50,  "children": [] }, { "name": "correct", "size": 50,  "children": [] }, { "name": "multisetorderingOp", "size": 50,  "children": [] }, { "name": "sbstInstOrRel", "size": 50,  "children": [] }, { "name": "complete", "size": 50,  "children": [] }, { "name": "FOUnifCalc", "size": 50,  "children": [] }, { "name": "more general", "size": 50,  "children": [] }, { "name": "substeq", "size": 50,  "children": [] }, { "name": "eqsubst", "size": 50,  "children": [] }, { "name": "unifiable", "size": 50,  "children": [] }, { "name": "unifier", "size": 50,  "children": [] }, { "name": "multiset ordering", "size": 50,  "children": [] }, { "name": "FOUtriv", "size": 50,  "children": [] }, { "name": "FOUdec", "size": 50,  "children": [] }, { "name": "unification problem", "size": 50,  "children": [] }, { "name": "sbstEqOn", "size": 50,  "children": [] }, { "name": "FOUelim", "size": 50,  "children": [] }, { "name": "reducible", "size": 50,  "children": [] }, { "name": "unification", "size": 50,  "children": [] }, { "name": "WfUni", "size": 50,  "children": [] }, { "name": "solved form", "size": 50,  "children": [] }, ] }, { "name": "Implementing First-Order Tableaux", "size": 50, "children": [{ "name": "multiplicity", "size": 50,  "children": [] }, { "name": "spanning mating", "size": 50,  "children": [] }, { "name": "mating", "size": 50,  "children": [] }, ] }, { "name": "First-Order Tableau Calculi", "size": 50, "children": [{ "name": "closed", "size": 50,  "children": [] }, { "name": "tableau proof", "size": 50,  "children": [] }, { "name": "FOTabcut", "size": 50,  "children": [] }, { "name": "tableau refutation", "size": 50,  "children": [] }, { "name": "open", "size": 50,  "children": [] }, { "name": "derive", "size": 50, "color": "red",  "children": [] }, { "name": "free variable tableau calculus", "size": 50,  "children": [] }, { "name": "FOTabexists", "size": 50,  "children": [] }, { "name": "standard tableau calculus", "size": 50,  "children": [] }, { "name": "taband", "size": 50,  "children": [] }, { "name": "tabcut", "size": 50,  "children": [] }, { "name": "tableau", "size": 50,  "children": [] }, { "name": "theorem", "size": 50, "color": "red",  "children": [] }, { "name": "tabnegtrue", "size": 50,  "children": [] }, { "name": "FOTabforall", "size": 50,  "children": [] }, { "name": "tabclose", "size": 50,  "children": [] }, { "name": "saturate", "size": 50,  "children": [] }, { "name": "sFOTabforall", "size": 50,  "children": [] }, { "name": "sFOTabexists", "size": 50,  "children": [] }, { "name": "PropTabCalc", "size": 50,  "children": [] }, { "name": "tabnegfalse", "size": 50,  "children": [] }, { "name": "tabor", "size": 50,  "children": [] }, { "name": "initial", "size": 50,  "children": [] }, ] }, { "name": "pair", "size": 50,  "children": [] }, { "name": "solved pair", "size": 50,  "children": [] }, { "name": "tableau proof", "size": 50,  "children": [] }, { "name": "solved variable", "size": 50,  "children": [] }, { "name": "unitary", "size": 50,  "children": [] }, { "name": "FOTabexists", "size": 50,  "children": [] }, { "name": "complete", "size": 50,  "children": [] }, { "name": "tableau", "size": 50,  "children": [] }, { "name": "FOUnifCalc", "size": 50,  "children": [] }, { "name": "theorem", "size": 50, "color": "red",  "children": [] }, { "name": "more general", "size": 50,  "children": [] }, { "name": "FOUDagCalc", "size": 50,  "children": [] }, { "name": "nodelabel", "size": 50,  "children": [] }, { "name": "unifiable", "size": 50,  "children": [] }, { "name": "tabclose", "size": 50,  "children": [] }, { "name": "saturate", "size": 50,  "children": [] }, { "name": "multiset ordering", "size": 50,  "children": [] }, { "name": "FOUtriv", "size": 50,  "children": [] }, { "name": "sFOTabforall", "size": 50,  "children": [] }, { "name": "PropTabCalc", "size": 50,  "children": [] }, { "name": "unification problem", "size": 50,  "children": [] }, { "name": "tabnegfalse", "size": 50,  "children": [] }, { "name": "tabor", "size": 50,  "children": [] }, { "name": "unification", "size": 50,  "children": [] }, { "name": "solved form", "size": 50,  "children": [] }, { "name": "DAG solved form", "size": 50,  "children": [] }, { "name": "WfUni", "size": 50,  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "multiplicity", "size": 50,  "children": [] }, { "name": "termweight", "size": 50,  "children": [] }, { "name": "sbstInstOr", "size": 50,  "children": [] }, { "name": "FOUDagevar", "size": 50,  "children": [] }, { "name": "FOTabcut", "size": 50,  "children": [] }, { "name": "mgu", "size": 50,  "children": [] }, { "name": "tableau refutation", "size": 50,  "children": [] }, { "name": "correct", "size": 50,  "children": [] }, { "name": "open", "size": 50,  "children": [] }, { "name": "derive", "size": 50, "color": "red",  "children": [] }, { "name": "free variable tableau calculus", "size": 50,  "children": [] }, { "name": "multisetorderingOp", "size": 50,  "children": [] }, { "name": "standard tableau calculus", "size": 50,  "children": [] }, { "name": "FOUDagmerge", "size": 50,  "children": [] }, { "name": "sbstInstOrRel", "size": 50,  "children": [] }, { "name": "taband", "size": 50,  "children": [] }, { "name": "tabcut", "size": 50,  "children": [] }, { "name": "tabnegtrue", "size": 50,  "children": [] }, { "name": "substeq", "size": 50,  "children": [] }, { "name": "eqsubst", "size": 50,  "children": [] }, { "name": "unifier", "size": 50,  "children": [] }, { "name": "FOUdec", "size": 50,  "children": [] }, { "name": "sFOTabexists", "size": 50,  "children": [] }, { "name": "sbstEqOn", "size": 50,  "children": [] }, { "name": "FOUelim", "size": 50,  "children": [] }, { "name": "spanning mating", "size": 50,  "children": [] }, { "name": "reducible", "size": 50,  "children": [] }, { "name": "FOTabforall", "size": 50,  "children": [] }, { "name": "initial", "size": 50,  "children": [] }, { "name": "mating", "size": 50,  "children": [] }, ] }, { "name": "First-Order Resolution", "size": 50, "children": [{ "name": "Resolution Examples", "size": 50, "children": [] }, { "name": "first-order resolution calculus", "size": 50,  "children": [] }, { "name": "first-order CNF", "size": 50,  "children": [] }, { "name": "first-order CNF calculus", "size": 50,  "children": [] }, ] }, { "name": "Logic Programming as Resolution Theorem Proving", "size": 50, "children": [{ "name": "Horn logic", "size": 50,  "children": [] }, { "name": "rule clause", "size": 50,  "children": [] }, { "name": "deduction", "size": 50,  "children": [] }, { "name": "induction", "size": 50,  "children": [] }, { "name": "Horn clause", "size": 50,  "children": [] }, { "name": "abduction", "size": 50,  "children": [] }, { "name": "HornCalc", "size": 50,  "children": [] }, { "name": "logic program", "size": 50,  "children": [] }, { "name": "answer substitution", "size": 50,  "children": [] }, { "name": "fact clause", "size": 50,  "children": [] }, { "name": "entails", "size": 50,  "children": [] }, { "name": "query", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "pair", "size": 50,  "children": [] }, { "name": "Horn logic", "size": 50,  "children": [] }, { "name": "solved pair", "size": 50,  "children": [] }, { "name": "unitary", "size": 50,  "children": [] }, { "name": "logic program", "size": 50,  "children": [] }, { "name": "first-order resolution calculus", "size": 50,  "children": [] }, { "name": "sFOTabforall", "size": 50,  "children": [] }, { "name": "multiset ordering", "size": 50,  "children": [] }, { "name": "PropTabCalc", "size": 50,  "children": [] }, { "name": "answer substitution", "size": 50,  "children": [] }, { "name": "unification", "size": 50,  "children": [] }, { "name": "DAG solved form", "size": 50,  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "termweight", "size": 50,  "children": [] }, { "name": "sbstInstOr", "size": 50,  "children": [] }, { "name": "FOUDagevar", "size": 50,  "children": [] }, { "name": "FOTabcut", "size": 50,  "children": [] }, { "name": "mgu", "size": 50,  "children": [] }, { "name": "tableau refutation", "size": 50,  "children": [] }, { "name": "correct", "size": 50,  "children": [] }, { "name": "open", "size": 50,  "children": [] }, { "name": "multisetorderingOp", "size": 50,  "children": [] }, { "name": "substeq", "size": 50,  "children": [] }, { "name": "Horn clause", "size": 50,  "children": [] }, { "name": "FOTabforall", "size": 50,  "children": [] }, { "name": "initial", "size": 50,  "children": [] }, { "name": "mating", "size": 50,  "children": [] }, { "name": "rule clause", "size": 50,  "children": [] }, { "name": "tableau proof", "size": 50,  "children": [] }, { "name": "solved variable", "size": 50,  "children": [] }, { "name": "abduction", "size": 50,  "children": [] }, { "name": "FOTabexists", "size": 50,  "children": [] }, { "name": "complete", "size": 50,  "children": [] }, { "name": "tableau", "size": 50,  "children": [] }, { "name": "FOUnifCalc", "size": 50,  "children": [] }, { "name": "theorem", "size": 50, "color": "red",  "children": [] }, { "name": "more general", "size": 50,  "children": [] }, { "name": "FOUDagCalc", "size": 50,  "children": [] }, { "name": "nodelabel", "size": 50,  "children": [] }, { "name": "unifiable", "size": 50,  "children": [] }, { "name": "tabclose", "size": 50,  "children": [] }, { "name": "saturate", "size": 50,  "children": [] }, { "name": "FOUtriv", "size": 50,  "children": [] }, { "name": "first-order CNF calculus", "size": 50,  "children": [] }, { "name": "unification problem", "size": 50,  "children": [] }, { "name": "tabnegfalse", "size": 50,  "children": [] }, { "name": "tabor", "size": 50,  "children": [] }, { "name": "entails", "size": 50,  "children": [] }, { "name": "solved form", "size": 50,  "children": [] }, { "name": "WfUni", "size": 50,  "children": [] }, { "name": "multiplicity", "size": 50,  "children": [] }, { "name": "first-order CNF", "size": 50,  "children": [] }, { "name": "derive", "size": 50, "color": "red",  "children": [] }, { "name": "free variable tableau calculus", "size": 50,  "children": [] }, { "name": "standard tableau calculus", "size": 50,  "children": [] }, { "name": "fact clause", "size": 50,  "children": [] }, { "name": "FOUDagmerge", "size": 50,  "children": [] }, { "name": "sbstInstOrRel", "size": 50,  "children": [] }, { "name": "taband", "size": 50,  "children": [] }, { "name": "tabcut", "size": 50,  "children": [] }, { "name": "tabnegtrue", "size": 50,  "children": [] }, { "name": "eqsubst", "size": 50,  "children": [] }, { "name": "unifier", "size": 50,  "children": [] }, { "name": "induction", "size": 50,  "children": [] }, { "name": "FOUdec", "size": 50,  "children": [] }, { "name": "sFOTabexists", "size": 50,  "children": [] }, { "name": "sbstEqOn", "size": 50,  "children": [] }, { "name": "FOUelim", "size": 50,  "children": [] }, { "name": "spanning mating", "size": 50,  "children": [] }, { "name": "HornCalc", "size": 50,  "children": [] }, { "name": "reducible", "size": 50,  "children": [] }, { "name": "deduction", "size": 50,  "children": [] }, { "name": "query", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Excursions", "size": 50, "children": [{ "name": "Completeness of Calculi for First-Order Logic", "size": 50, "children": [{ "name": "Soundness and Completeness of First-Order Tableaux", "size": 50, "children": [] }, { "name": "A Completeness Proof for First-Order ND", "size": 50, "children": [] }, { "name": "Soundness and Completeness of First-Order Resolution", "size": 50, "children": [{ "name": "clauseset iso", "size": 50,  "children": [] }, { "name": "theta compatible", "size": 50,  "children": [] }, { "name": "clause iso", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, ] }, { "name": "Abstract Consistency and Model Existence", "size": 50, "children": [{ "name": "absforall", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "reasonable", "size": 50,  "children": [] }, { "name": "refute", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "absexists", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "closed under subsets", "size": 50,  "children": [] }, { "name": "compact", "size": 50,  "children": [] }, { "name": "hintforall", "size": 50,  "children": [] }, { "name": "nabla HS", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "refutable", "size": 50,  "children": [] }, { "name": "hintexists", "size": 50,  "children": [] }, { "name": "contradiction", "size": 50,  "children": [] }, ] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "clauseset iso", "size": 50,  "children": [] }, { "name": "absforall", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "reasonable", "size": 50,  "children": [] }, { "name": "refute", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "absexists", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "closed under subsets", "size": 50,  "children": [] }, { "name": "compact", "size": 50,  "children": [] }, { "name": "hintforall", "size": 50,  "children": [] }, { "name": "nabla HS", "size": 50,  "children": [] }, { "name": "clause iso", "size": 50,  "children": [] }, { "name": "theta compatible", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "refutable", "size": 50,  "children": [] }, { "name": "hintexists", "size": 50,  "children": [] }, { "name": "contradiction", "size": 50,  "children": [] }, ] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "clauseset iso", "size": 50,  "children": [] }, { "name": "absforall", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "reasonable", "size": 50,  "children": [] }, { "name": "refute", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "absexists", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "closed under subsets", "size": 50,  "children": [] }, { "name": "compact", "size": 50,  "children": [] }, { "name": "hintforall", "size": 50,  "children": [] }, { "name": "nabla HS", "size": 50,  "children": [] }, { "name": "clause iso", "size": 50,  "children": [] }, { "name": "theta compatible", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "refutable", "size": 50,  "children": [] }, { "name": "hintexists", "size": 50,  "children": [] }, { "name": "contradiction", "size": 50,  "children": [] }, ] }, { "name": "First-Order Predicate Logic", "size": 50, "children": [{ "name": "First-Order Logic", "size": 50, "children": [{ "name": "First-Order Substitutions", "size": 50, "children": [{ "name": "extension", "size": 50,  "children": [] }, { "name": "sbstList", "size": 50,  "children": [] }, { "name": "substitution", "size": 50,  "children": [] }, { "name": "sbstListdots", "size": 50,  "children": [] }, { "name": "empty substitution", "size": 50,  "children": [] }, { "name": "substitution application", "size": 50,  "children": [] }, { "name": "support", "size": 50,  "children": [] }, { "name": "discharge", "size": 50,  "children": [] }, { "name": "capture-avoiding", "size": 50,  "children": [] }, { "name": "sbstListfromto", "size": 50,  "children": [] }, { "name": "sbst", "size": 50,  "children": [] }, ] }, { "name": "First-Order Logic: Syntax and Semantics", "size": 50, "children": [{ "name": "extend", "size": 50,  "children": [] }, { "name": "universal quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "connective", "size": 50, "color": "red",  "children": [] }, { "name": "bound", "size": 50,  "children": [] }, { "name": "sentence", "size": 50,  "children": [] }, { "name": "Skolem constant", "size": 50, "color": "red",  "children": [] }, { "name": "first-order logic", "size": 50, "color": "red",  "children": [] }, { "name": "proposition", "size": 50,  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "individual variable", "size": 50, "color": "red",  "children": [] }, { "name": "first-order signature", "size": 50, "color": "red",  "children": [] }, { "name": "free", "size": 50,  "children": [] }, { "name": "term", "size": 50, "color": "red",  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "predicate constant", "size": 50, "color": "red",  "children": [] }, { "name": "function constant", "size": 50, "color": "red",  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "FOUniverse", "size": 50,  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "alphabetical variant", "size": 50,  "children": [] }, { "name": "value function", "size": 50, "color": "red",  "children": [] }, { "name": "existential quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "bound variable occurrence", "size": 50,  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, ] }, { "name": "universal quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "sbstList", "size": 50,  "children": [] }, { "name": "connective", "size": 50, "color": "red",  "children": [] }, { "name": "substitution application", "size": 50,  "children": [] }, { "name": "individual variable", "size": 50, "color": "red",  "children": [] }, { "name": "capture-avoiding", "size": 50,  "children": [] }, { "name": "free", "size": 50,  "children": [] }, { "name": "term", "size": 50, "color": "red",  "children": [] }, { "name": "sbst", "size": 50,  "children": [] }, { "name": "substitution", "size": 50,  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "discharge", "size": 50,  "children": [] }, { "name": "existential quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, { "name": "extend", "size": 50,  "children": [] }, { "name": "sbstListdots", "size": 50,  "children": [] }, { "name": "bound", "size": 50,  "children": [] }, { "name": "support", "size": 50,  "children": [] }, { "name": "sentence", "size": 50,  "children": [] }, { "name": "Skolem constant", "size": 50, "color": "red",  "children": [] }, { "name": "proposition", "size": 50,  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "first-order signature", "size": 50, "color": "red",  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "predicate constant", "size": 50, "color": "red",  "children": [] }, { "name": "function constant", "size": 50, "color": "red",  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "extension", "size": 50,  "children": [] }, { "name": "empty substitution", "size": 50,  "children": [] }, { "name": "alphabetical variant", "size": 50,  "children": [] }, { "name": "value function", "size": 50, "color": "red",  "children": [] }, { "name": "sbstListfromto", "size": 50,  "children": [] }, { "name": "first-order logic", "size": 50, "color": "red",  "children": [] }, { "name": "bound variable occurrence", "size": 50,  "children": [] }, { "name": "FOUniverse", "size": 50,  "children": [] }, ] }, { "name": "First-Order Natural Deduction", "size": 50, "children": [{ "name": "NDexistsE", "size": 50,  "children": [] }, { "name": "SNDforallE", "size": 50,  "children": [] }, { "name": "SNDexistsE", "size": 50,  "children": [] }, { "name": "hasatpos", "size": 50,  "children": [] }, { "name": "FOLEQNDCalc", "size": 50,  "children": [] }, { "name": "SNDeqE", "size": 50,  "children": [] }, { "name": "position", "size": 50,  "children": [] }, { "name": "SNDforallI", "size": 50,  "children": [] }, { "name": "SNDexistsI", "size": 50,  "children": [] }, { "name": "NDequivE", "size": 50,  "children": [] }, { "name": "NDforallE", "size": 50,  "children": [] }, { "name": "NDequivI", "size": 50,  "children": [] }, { "name": "NDeqI", "size": 50,  "children": [] }, { "name": "FOLEQ", "size": 50,  "children": [] }, { "name": "first-order sequent calculus", "size": 50,  "children": [] }, { "name": "replace", "size": 50,  "children": [] }, { "name": "NDforallI", "size": 50,  "children": [] }, { "name": "NDexistsI", "size": 50,  "children": [] }, { "name": "FONDCalc", "size": 50,  "children": [] }, { "name": "SNDequivE", "size": 50,  "children": [] }, { "name": "SNDequivI", "size": 50,  "children": [] }, { "name": "SNDeqI", "size": 50,  "children": [] }, { "name": "NDeqE", "size": 50,  "children": [] }, { "name": "at position", "size": 50,  "children": [] }, { "name": "occurrence", "size": 50,  "children": [] }, ] }, { "name": "Motivation: A more Expressive Language", "size": 50, "children": [{ "name": "even", "size": 50,  "children": [] }, { "name": "isblock", "size": 50,  "children": [] }, { "name": "plus", "size": 50,  "children": [] }, { "name": "power", "size": 50,  "children": [] }, { "name": "gt", "size": 50,  "children": [] }, { "name": "equals", "size": 50,  "children": [] }, { "name": "succ", "size": 50,  "children": [] }, { "name": "isred", "size": 50,  "children": [] }, ] }, { "name": "Conclusion", "size": 50, "children": [] }, { "name": "SNDforallE", "size": 50,  "children": [] }, { "name": "universal quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "SNDexistsE", "size": 50,  "children": [] }, { "name": "connective", "size": 50, "color": "red",  "children": [] }, { "name": "capture-avoiding", "size": 50,  "children": [] }, { "name": "NDeqI", "size": 50,  "children": [] }, { "name": "first-order sequent calculus", "size": 50,  "children": [] }, { "name": "NDforallI", "size": 50,  "children": [] }, { "name": "sbst", "size": 50,  "children": [] }, { "name": "even", "size": 50,  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "existential quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, { "name": "extend", "size": 50,  "children": [] }, { "name": "FOLEQNDCalc", "size": 50,  "children": [] }, { "name": "sentence", "size": 50,  "children": [] }, { "name": "position", "size": 50,  "children": [] }, { "name": "isblock", "size": 50,  "children": [] }, { "name": "SNDexistsI", "size": 50,  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "NDequivI", "size": 50,  "children": [] }, { "name": "first-order signature", "size": 50, "color": "red",  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "FOLEQ", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "predicate constant", "size": 50, "color": "red",  "children": [] }, { "name": "isred", "size": 50,  "children": [] }, { "name": "function constant", "size": 50, "color": "red",  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "plus", "size": 50,  "children": [] }, { "name": "alphabetical variant", "size": 50,  "children": [] }, { "name": "first-order logic", "size": 50, "color": "red",  "children": [] }, { "name": "bound variable occurrence", "size": 50,  "children": [] }, { "name": "NDexistsE", "size": 50,  "children": [] }, { "name": "sbstList", "size": 50,  "children": [] }, { "name": "substitution application", "size": 50,  "children": [] }, { "name": "SNDforallI", "size": 50,  "children": [] }, { "name": "individual variable", "size": 50, "color": "red",  "children": [] }, { "name": "NDforallE", "size": 50,  "children": [] }, { "name": "gt", "size": 50,  "children": [] }, { "name": "free", "size": 50,  "children": [] }, { "name": "term", "size": 50, "color": "red",  "children": [] }, { "name": "replace", "size": 50,  "children": [] }, { "name": "equals", "size": 50,  "children": [] }, { "name": "succ", "size": 50,  "children": [] }, { "name": "substitution", "size": 50,  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "FONDCalc", "size": 50,  "children": [] }, { "name": "discharge", "size": 50,  "children": [] }, { "name": "SNDequivE", "size": 50,  "children": [] }, { "name": "SNDequivI", "size": 50,  "children": [] }, { "name": "SNDeqI", "size": 50,  "children": [] }, { "name": "at position", "size": 50,  "children": [] }, { "name": "sbstListdots", "size": 50,  "children": [] }, { "name": "hasatpos", "size": 50,  "children": [] }, { "name": "bound", "size": 50,  "children": [] }, { "name": "support", "size": 50,  "children": [] }, { "name": "SNDeqE", "size": 50,  "children": [] }, { "name": "Skolem constant", "size": 50, "color": "red",  "children": [] }, { "name": "proposition", "size": 50,  "children": [] }, { "name": "NDequivE", "size": 50,  "children": [] }, { "name": "extension", "size": 50,  "children": [] }, { "name": "empty substitution", "size": 50,  "children": [] }, { "name": "NDexistsI", "size": 50,  "children": [] }, { "name": "value function", "size": 50, "color": "red",  "children": [] }, { "name": "power", "size": 50,  "children": [] }, { "name": "sbstListfromto", "size": 50,  "children": [] }, { "name": "NDeqE", "size": 50,  "children": [] }, { "name": "occurrence", "size": 50,  "children": [] }, { "name": "FOUniverse", "size": 50,  "children": [] }, ] }, { "name": "Propositional Logic & Reasoning, Part I: Principles", "size": 50, "children": [{ "name": "Conclusion", "size": 50, "children": [] }, { "name": "Introduction", "size": 50, "children": [{ "name": "logic-based agent", "size": 50,  "children": [] }, { "name": "Wumpus world", "size": 50,  "children": [] }, { "name": "entails", "size": 50, "color": "red",  "children": [] }, { "name": "sound", "size": 50, "color": "red",  "children": [] }, { "name": "complete", "size": 50, "color": "red",  "children": [] }, { "name": "semantics", "size": 50,  "children": [] }, { "name": "deduction", "size": 50,  "children": [] }, { "name": "pit", "size": 50,  "children": [] }, { "name": "formula", "size": 50, "color": "lightred",  "children": [] }, { "name": "gold", "size": 50,  "children": [] }, { "name": "assignment", "size": 50,  "children": [] }, { "name": "Wumpus", "size": 50,  "children": [] }, { "name": "calculus", "size": 50, "color": "red",  "children": [] }, { "name": "syntax", "size": 50,  "children": [] }, { "name": "derived", "size": 50,  "children": [] }, { "name": "cell", "size": 50,  "children": [] }, ] }, { "name": "Propositional Logic (Syntax/Semantics)", "size": 50, "children": [{ "name": "connective", "size": 50, "color": "red",  "children": [] }, { "name": "conjunct", "size": 50, "color": "red",  "children": [] }, { "name": "propositional variable", "size": 50, "color": "red",  "children": [] }, { "name": "entails", "size": 50, "color": "red",  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "universe", "size": 50, "color": "red",  "children": [] }, { "name": "falsifiable in", "size": 50,  "children": [] }, { "name": "falsifies", "size": 50,  "children": [] }, { "name": "unsatisfiable in", "size": 50,  "children": [] }, { "name": "negation", "size": 50, "color": "orange",  "children": [] }, { "name": "valid in", "size": 50,  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "equivalence", "size": 50, "color": "red",  "children": [] }, { "name": "satisfiable in", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "conjunction", "size": 50, "color": "lightred",  "children": [] }, { "name": "satisfies", "size": 50,  "children": [] }, { "name": "disjunction", "size": 50, "color": "lightred",  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "logical constant", "size": 50, "color": "red",  "children": [] }, { "name": "disjunct", "size": 50, "color": "lightred",  "children": [] }, { "name": "propositional logic", "size": 50, "color": "red",  "children": [] }, { "name": "implication", "size": 50, "color": "red",  "children": [] }, { "name": "value function", "size": 50, "color": "red",  "children": [] }, { "name": "propUniverse", "size": 50,  "children": [] }, { "name": "proposition", "size": 50, "color": "red",  "children": [] }, { "name": "expression", "size": 50, "color": "red",  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, ] }, { "name": "Propositional Natural Deduction Calculus", "size": 50, "children": [{ "name": "NDfalseI", "size": 50,  "children": [] }, { "name": "propositional natural deduction calculus", "size": 50,  "children": [] }, { "name": "NDhyp", "size": 50,  "children": [] }, { "name": "propSNDcalc", "size": 50,  "children": [] }, { "name": "axiom rule", "size": 50,  "children": [] }, { "name": "linearized notation for sequent-style ND proofs", "size": 50,  "children": [] }, { "name": "disjunction elimination", "size": 50,  "children": [] }, { "name": "conjunction elimination right", "size": 50,  "children": [] }, { "name": "implication introduction", "size": 50,  "children": [] }, { "name": "conjunction elimination left", "size": 50,  "children": [] }, { "name": "conjunction elimination right", "size": 50,  "children": [] }, { "name": "negation elimination", "size": 50,  "children": [] }, { "name": "conjunction introduction", "size": 50,  "children": [] }, { "name": "conjunction introduction", "size": 50,  "children": [] }, { "name": "implication elimination", "size": 50,  "children": [] }, { "name": "false elimination", "size": 50,  "children": [] }, { "name": "implication elimination", "size": 50,  "children": [] }, { "name": "conclusion", "size": 50, "color": "red",  "children": [] }, { "name": "discharge", "size": 50, "color": "lightred",  "children": [] }, { "name": "assumption", "size": 50, "color": "red",  "children": [] }, { "name": "sequent", "size": 50,  "children": [] }, { "name": "tertium non datur", "size": 50,  "children": [] }, { "name": "negation introduction", "size": 50,  "children": [] }, { "name": "conjunction elimination left", "size": 50,  "children": [] }, { "name": "implication introduction", "size": 50,  "children": [] }, { "name": "local hypothesis", "size": 50,  "children": [] }, { "name": "NDorIR", "size": 50,  "children": [] }, { "name": "hypothetical reasoning", "size": 50,  "children": [] }, { "name": "NDorIL", "size": 50,  "children": [] }, { "name": "NDfalseE", "size": 50,  "children": [] }, { "name": "weakening", "size": 50,  "children": [] }, { "name": "judgment", "size": 50,  "children": [] }, { "name": "tertium non datur", "size": 50,  "children": [] }, { "name": "false introduction", "size": 50,  "children": [] }, { "name": "NDorE", "size": 50,  "children": [] }, { "name": "NDaxiom", "size": 50,  "children": [] }, { "name": "disjunction introduction right", "size": 50,  "children": [] }, { "name": "disjunction introduction left", "size": 50,  "children": [] }, { "name": "NDnegE", "size": 50,  "children": [] }, { "name": "NDnegI", "size": 50,  "children": [] }, ] }, { "name": "Inference in Propositional Logics", "size": 50, "children": [{ "name": "logic-based agent", "size": 50,  "children": [] }, { "name": "modus ponens", "size": 50,  "children": [] }, { "name": "SAxiom", "size": 50,  "children": [] }, { "name": "KAxiom", "size": 50,  "children": [] }, { "name": "Hilbert calculus", "size": 50,  "children": [] }, { "name": "sound", "size": 50, "color": "red",  "children": [] }, { "name": "complete", "size": 50, "color": "red",  "children": [] }, { "name": "substitution rule", "size": 50,  "children": [] }, ] }, { "name": "Predicate Logic Without Quantifiers", "size": 50, "children": [{ "name": "function constant", "size": 50, "color": "red",  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "truth value", "size": 50, "color": "red",  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "PLNQ", "size": 50,  "children": [] }, { "name": "value function", "size": 50, "color": "red",  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "first-order signature", "size": 50, "color": "red",  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "predicate constant", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "NDfalseI", "size": 50,  "children": [] }, { "name": "connective", "size": 50, "color": "red",  "children": [] }, { "name": "entails", "size": 50, "color": "red",  "children": [] }, { "name": "linearized notation for sequent-style ND proofs", "size": 50,  "children": [] }, { "name": "KAxiom", "size": 50,  "children": [] }, { "name": "sound", "size": 50, "color": "red",  "children": [] }, { "name": "falsifies", "size": 50,  "children": [] }, { "name": "disjunction elimination", "size": 50,  "children": [] }, { "name": "conjunction elimination right", "size": 50,  "children": [] }, { "name": "conjunction elimination left", "size": 50,  "children": [] }, { "name": "negation elimination", "size": 50,  "children": [] }, { "name": "disjunction", "size": 50, "color": "lightred",  "children": [] }, { "name": "conjunction introduction", "size": 50,  "children": [] }, { "name": "logical constant", "size": 50, "color": "red",  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "false elimination", "size": 50,  "children": [] }, { "name": "implication", "size": 50, "color": "red",  "children": [] }, { "name": "implication elimination", "size": 50,  "children": [] }, { "name": "proposition", "size": 50, "color": "red",  "children": [] }, { "name": "conclusion", "size": 50, "color": "red",  "children": [] }, { "name": "syntax", "size": 50,  "children": [] }, { "name": "substitution rule", "size": 50,  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, { "name": "tertium non datur", "size": 50,  "children": [] }, { "name": "logic-based agent", "size": 50,  "children": [] }, { "name": "implication introduction", "size": 50,  "children": [] }, { "name": "propositional variable", "size": 50, "color": "red",  "children": [] }, { "name": "Wumpus world", "size": 50,  "children": [] }, { "name": "NDorIR", "size": 50,  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "falsifiable in", "size": 50,  "children": [] }, { "name": "unsatisfiable in", "size": 50,  "children": [] }, { "name": "semantics", "size": 50,  "children": [] }, { "name": "valid in", "size": 50,  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "negation", "size": 50, "color": "orange",  "children": [] }, { "name": "first-order signature", "size": 50, "color": "red",  "children": [] }, { "name": "satisfiable in", "size": 50,  "children": [] }, { "name": "hypothetical reasoning", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "predicate constant", "size": 50, "color": "red",  "children": [] }, { "name": "NDorIL", "size": 50,  "children": [] }, { "name": "function constant", "size": 50, "color": "red",  "children": [] }, { "name": "NDfalseE", "size": 50,  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "gold", "size": 50,  "children": [] }, { "name": "calculus", "size": 50, "color": "red",  "children": [] }, { "name": "judgment", "size": 50,  "children": [] }, { "name": "false introduction", "size": 50,  "children": [] }, { "name": "tertium non datur", "size": 50,  "children": [] }, { "name": "NDaxiom", "size": 50,  "children": [] }, { "name": "disjunction introduction left", "size": 50,  "children": [] }, { "name": "propUniverse", "size": 50,  "children": [] }, { "name": "derived", "size": 50,  "children": [] }, { "name": "NDnegI", "size": 50,  "children": [] }, { "name": "propositional natural deduction calculus", "size": 50,  "children": [] }, { "name": "NDhyp", "size": 50,  "children": [] }, { "name": "conjunct", "size": 50, "color": "red",  "children": [] }, { "name": "propSNDcalc", "size": 50,  "children": [] }, { "name": "axiom rule", "size": 50,  "children": [] }, { "name": "PLNQ", "size": 50,  "children": [] }, { "name": "complete", "size": 50, "color": "red",  "children": [] }, { "name": "implication introduction", "size": 50,  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "equivalence", "size": 50, "color": "red",  "children": [] }, { "name": "conjunction elimination right", "size": 50,  "children": [] }, { "name": "conjunction", "size": 50, "color": "lightred",  "children": [] }, { "name": "conjunction introduction", "size": 50,  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "assignment", "size": 50,  "children": [] }, { "name": "Wumpus", "size": 50,  "children": [] }, { "name": "implication elimination", "size": 50,  "children": [] }, { "name": "disjunct", "size": 50, "color": "lightred",  "children": [] }, { "name": "discharge", "size": 50, "color": "lightred",  "children": [] }, { "name": "assumption", "size": 50, "color": "red",  "children": [] }, { "name": "sequent", "size": 50,  "children": [] }, { "name": "pit", "size": 50,  "children": [] }, { "name": "conjunction elimination left", "size": 50,  "children": [] }, { "name": "negation introduction", "size": 50,  "children": [] }, { "name": "modus ponens", "size": 50,  "children": [] }, { "name": "local hypothesis", "size": 50,  "children": [] }, { "name": "universe", "size": 50, "color": "red",  "children": [] }, { "name": "deduction", "size": 50,  "children": [] }, { "name": "truth value", "size": 50, "color": "red",  "children": [] }, { "name": "formula", "size": 50, "color": "lightred",  "children": [] }, { "name": "satisfies", "size": 50,  "children": [] }, { "name": "weakening", "size": 50,  "children": [] }, { "name": "SAxiom", "size": 50,  "children": [] }, { "name": "Hilbert calculus", "size": 50,  "children": [] }, { "name": "NDorE", "size": 50,  "children": [] }, { "name": "value function", "size": 50, "color": "red",  "children": [] }, { "name": "propositional logic", "size": 50, "color": "red",  "children": [] }, { "name": "disjunction introduction right", "size": 50,  "children": [] }, { "name": "NDnegE", "size": 50,  "children": [] }, { "name": "expression", "size": 50, "color": "red",  "children": [] }, { "name": "cell", "size": 50,  "children": [] }, ] }, { "name": "Propositional Reasoning: SAT Solvers", "size": 50, "children": [{ "name": "Conclusion", "size": 50, "children": [{ "name": "GSAT algorithm", "size": 50,  "children": [] }, ] }, { "name": "The Davis-Putnam (Logemann-Loveland) Procedure", "size": 50, "children": [{ "name": "UP", "size": 50,  "children": [] }, { "name": "splitting", "size": 50,  "children": [] }, { "name": "DPLL", "size": 50,  "children": [] }, ] }, { "name": "DPLL ?   (A Restricted Form of) Resolution", "size": 50, "children": [{ "name": "tree resolution", "size": 50,  "children": [] }, { "name": "number of decisions", "size": 50,  "children": [] }, { "name": "UR", "size": 50,  "children": [] }, ] }, { "name": "Introduction", "size": 50, "children": [{ "name": "SAT problem", "size": 50,  "children": [] }, { "name": "SAT", "size": 50,  "children": [] }, { "name": "SAT solver", "size": 50,  "children": [] }, ] }, { "name": "tree resolution", "size": 50,  "children": [] }, { "name": "UP", "size": 50,  "children": [] }, { "name": "SAT", "size": 50,  "children": [] }, { "name": "GSAT algorithm", "size": 50,  "children": [] }, { "name": "DPLL", "size": 50,  "children": [] }, { "name": "UR", "size": 50,  "children": [] }, { "name": "number of decisions", "size": 50,  "children": [] }, { "name": "SAT solver", "size": 50,  "children": [] }, { "name": "SAT problem", "size": 50,  "children": [] }, { "name": "splitting", "size": 50,  "children": [] }, ] }, { "name": ": , ", "size": 50, "children": [{ "name": "formula", "size": 50, "color": "red",  "children": [] }, { "name": "falsifiable", "size": 50, "color": "red",  "children": [] }, { "name": "proof", "size": 50,  "children": [] }, { "name": "derivation relation", "size": 50,  "children": [] }, { "name": "hypothesis", "size": 50, "color": "red",  "children": [] }, { "name": "formal system", "size": 50, "color": "red",  "children": [] }, { "name": "derivable", "size": 50, "color": "red",  "children": [] }, { "name": "sinvalid", "size": 50,  "children": [] }, { "name": "nderives", "size": 50,  "children": [] }, { "name": "theorem", "size": 50, "color": "red",  "children": [] }, { "name": "inference rule", "size": 50, "color": "red",  "children": [] }, { "name": "falsified", "size": 50, "color": "red",  "children": [] }, { "name": "satisfiable", "size": 50, "color": "red",  "children": [] }, { "name": "derivation tree", "size": 50, "color": "red",  "children": [] }, { "name": "valid", "size": 50, "color": "red",  "children": [] }, { "name": "invalidin", "size": 50, "color": "red",  "children": [] }, { "name": "satisfaction relation", "size": 50, "color": "red",  "children": [] }, { "name": "validin", "size": 50, "color": "red",  "children": [] }, { "name": "infruleref", "size": 50,  "children": [] }, { "name": "calc", "size": 50, "color": "red",  "children": [] }, { "name": "proof reflexive", "size": 50,  "children": [] }, { "name": "conclusion", "size": 50, "color": "red",  "children": [] }, { "name": "proof transitive", "size": 50,  "children": [] }, { "name": "assumption", "size": 50, "color": "red",  "children": [] }, { "name": "satisfied", "size": 50, "color": "red",  "children": [] }, { "name": "modcls", "size": 50, "color": "red",  "children": [] }, { "name": "axiom", "size": 50, "color": "red",  "children": [] }, { "name": "flang", "size": 50, "color": "red",  "children": [] }, { "name": "svalid", "size": 50,  "children": [] }, { "name": "infruledef", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "derivation", "size": 50, "color": "lightred",  "children": [] }, { "name": "invalid", "size": 50,  "children": [] }, { "name": "admissible", "size": 50,  "children": [] }, { "name": "monotonic", "size": 50,  "children": [] }, { "name": "unsatisfiable", "size": 50, "color": "red",  "children": [] }, { "name": "calculus", "size": 50, "color": "red",  "children": [] }, { "name": "prove", "size": 50,  "children": [] }, { "name": "logical system", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Machine-Oriented Calculi for Propositional Logic", "size": 50, "children": [{ "name": "Practical Enhancements for Tableaux", "size": 50, "children": [{ "name": "derivable", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Normal Forms", "size": 50, "children": [{ "name": "negative", "size": 50, "color": "lightred",  "children": [] }, { "name": "negative", "size": 50,  "children": [] }, { "name": "opposite literal", "size": 50,  "children": [] }, { "name": "labeled formulae", "size": 50,  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "literal", "size": 50, "color": "red",  "children": [] }, { "name": "opposite literal", "size": 50,  "children": [] }, { "name": "DNF", "size": 50, "color": "lightred",  "children": [] }, { "name": "literal", "size": 50, "color": "lightred",  "children": [] }, { "name": "labeled formula", "size": 50, "color": "red",  "children": [] }, { "name": "positive", "size": 50, "color": "lightred",  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, { "name": "CNF", "size": 50, "color": "orange",  "children": [] }, { "name": "positive", "size": 50,  "children": [] }, ] }, { "name": "Analytical Tableaux", "size": 50, "children": [{ "name": "closed", "size": 50,  "children": [] }, { "name": "tableau proof", "size": 50,  "children": [] }, { "name": "tableau refutation", "size": 50,  "children": [] }, { "name": "open", "size": 50,  "children": [] }, { "name": "derive", "size": 50, "color": "red",  "children": [] }, { "name": "taband", "size": 50,  "children": [] }, { "name": "tabcut", "size": 50,  "children": [] }, { "name": "tableau", "size": 50,  "children": [] }, { "name": "theorem", "size": 50, "color": "red",  "children": [] }, { "name": "tabnegtrue", "size": 50,  "children": [] }, { "name": "tabclose", "size": 50,  "children": [] }, { "name": "saturate", "size": 50,  "children": [] }, { "name": "PropTabCalc", "size": 50,  "children": [] }, { "name": "tabnegfalse", "size": 50,  "children": [] }, { "name": "tabor", "size": 50,  "children": [] }, { "name": "initial", "size": 50,  "children": [] }, ] }, { "name": "Killing a Wumpus with Propositional Inference", "size": 50, "children": [] }, { "name": "Resolution for Propositional Logic", "size": 50, "children": [{ "name": "resolve", "size": 50,  "children": [] }, { "name": "PropCNFCalc", "size": 50,  "children": [] }, { "name": "resolution calculus", "size": 50,  "children": [] }, { "name": "mrclause", "size": 50,  "children": [] }, { "name": "derivable", "size": 50, "color": "red",  "children": [] }, { "name": "mrclauseCollection", "size": 50,  "children": [] }, { "name": "mrclauseProp", "size": 50,  "children": [] }, { "name": "empty clause", "size": 50,  "children": [] }, { "name": "PropCNF", "size": 50,  "children": [] }, { "name": "unit clause", "size": 50,  "children": [] }, { "name": "resolvent", "size": 50,  "children": [] }, { "name": "cut literal", "size": 50,  "children": [] }, { "name": "rclausesetext", "size": 50,  "children": [] }, { "name": "clause set", "size": 50,  "children": [] }, { "name": "rclauseset", "size": 50,  "children": [] }, { "name": "resolution rule", "size": 50,  "children": [] }, { "name": "clause set simplification", "size": 50,  "children": [] }, { "name": "rclausesetunion", "size": 50,  "children": [] }, { "name": "resolution proof", "size": 50,  "children": [] }, { "name": "clause", "size": 50, "color": "red",  "children": [] }, ] }, { "name": "Soundness and Termination of Tableaux", "size": 50, "children": [{ "name": "termmeasure", "size": 50,  "children": [] }, { "name": "valid under", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50, "color": "red",  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "worked off", "size": 50,  "children": [] }, ] }, { "name": "PropCNFCalc", "size": 50,  "children": [] }, { "name": "mrclause", "size": 50,  "children": [] }, { "name": "derivable", "size": 50, "color": "red",  "children": [] }, { "name": "literal", "size": 50, "color": "red",  "children": [] }, { "name": "testcompl", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50, "color": "red",  "children": [] }, { "name": "PropTabCalc", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, { "name": "resolution proof", "size": 50,  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "resolution calculus", "size": 50,  "children": [] }, { "name": "negative", "size": 50, "color": "lightred",  "children": [] }, { "name": "ATPer", "size": 50,  "children": [] }, { "name": "tableau refutation", "size": 50,  "children": [] }, { "name": "labeled formulae", "size": 50,  "children": [] }, { "name": "open", "size": 50,  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "empty clause", "size": 50,  "children": [] }, { "name": "resolvent", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "rclausesetext", "size": 50,  "children": [] }, { "name": "rclauseset", "size": 50,  "children": [] }, { "name": "literal", "size": 50, "color": "lightred",  "children": [] }, { "name": "testunsat", "size": 50,  "children": [] }, { "name": "initial", "size": 50,  "children": [] }, { "name": "PropCNF", "size": 50,  "children": [] }, { "name": "clause", "size": 50, "color": "red",  "children": [] }, { "name": "tableau proof", "size": 50,  "children": [] }, { "name": "hypothesis", "size": 50, "color": "red",  "children": [] }, { "name": "mrclauseCollection", "size": 50,  "children": [] }, { "name": "conjecture", "size": 50,  "children": [] }, { "name": "tableau", "size": 50,  "children": [] }, { "name": "theorem", "size": 50, "color": "red",  "children": [] }, { "name": "positive", "size": 50,  "children": [] }, { "name": "cut literal", "size": 50,  "children": [] }, { "name": "clause set", "size": 50,  "children": [] }, { "name": "tabclose", "size": 50,  "children": [] }, { "name": "saturate", "size": 50,  "children": [] }, { "name": "DNF", "size": 50, "color": "lightred",  "children": [] }, { "name": "tabnegfalse", "size": 50,  "children": [] }, { "name": "clause set simplification", "size": 50,  "children": [] }, { "name": "tabor", "size": 50,  "children": [] }, { "name": "labeled formula", "size": 50, "color": "red",  "children": [] }, { "name": "worked off", "size": 50,  "children": [] }, { "name": "resolve", "size": 50,  "children": [] }, { "name": "termmeasure", "size": 50,  "children": [] }, { "name": "negative", "size": 50,  "children": [] }, { "name": "theorem proving", "size": 50,  "children": [] }, { "name": "derive", "size": 50, "color": "red",  "children": [] }, { "name": "opposite literal", "size": 50,  "children": [] }, { "name": "test calculus", "size": 50,  "children": [] }, { "name": "mrclauseProp", "size": 50,  "children": [] }, { "name": "unit clause", "size": 50,  "children": [] }, { "name": "taband", "size": 50,  "children": [] }, { "name": "tabcut", "size": 50,  "children": [] }, { "name": "CNF", "size": 50, "color": "orange",  "children": [] }, { "name": "tabnegtrue", "size": 50,  "children": [] }, { "name": "valid under", "size": 50,  "children": [] }, { "name": "opposite literal", "size": 50,  "children": [] }, { "name": "ATP", "size": 50,  "children": [] }, { "name": "resolution rule", "size": 50,  "children": [] }, { "name": "positive", "size": 50, "color": "lightred",  "children": [] }, { "name": "rclausesetunion", "size": 50,  "children": [] }, ] }, { "name": "Excursions", "size": 50, "children": [{ "name": "Conflict Driven Clause Learning", "size": 50, "children": [{ "name": "   Did Unit Propagation Yield a Conflict?", "size": 50, "children": [{ "name": "implication graph", "size": 50,  "children": [] }, { "name": "choice literal", "size": 50,  "children": [] }, { "name": "conflict vertex", "size": 50,  "children": [] }, { "name": "conflict graph", "size": 50,  "children": [] }, { "name": "conflict literal", "size": 50,  "children": [] }, { "name": "implied literal", "size": 50,  "children": [] }, ] }, { "name": "Clause Learning", "size": 50, "children": [{ "name": "clause learning", "size": 50,  "children": [] }, { "name": "CDCL", "size": 50,  "children": [] }, { "name": "learned clause", "size": 50,  "children": [] }, ] }, { "name": "Phase Transitions: Where the    Hard Problems Are", "size": 50, "children": [{ "name": "order parameter", "size": 50,  "children": [] }, { "name": "critical value", "size": 50,  "children": [] }, { "name": "phase transition", "size": 50,  "children": [] }, ] }, { "name": "order parameter", "size": 50,  "children": [] }, { "name": "implication graph", "size": 50,  "children": [] }, { "name": "phase transition", "size": 50,  "children": [] }, { "name": "conflict graph", "size": 50,  "children": [] }, { "name": "CDCL", "size": 50,  "children": [] }, { "name": "learned clause", "size": 50,  "children": [] }, { "name": "conflict literal", "size": 50,  "children": [] }, { "name": "implied literal", "size": 50,  "children": [] }, { "name": "critical value", "size": 50,  "children": [] }, { "name": "clause learning", "size": 50,  "children": [] }, { "name": "choice literal", "size": 50,  "children": [] }, { "name": "conflict vertex", "size": 50,  "children": [] }, ] }, { "name": "order parameter", "size": 50,  "children": [] }, { "name": "implication graph", "size": 50,  "children": [] }, { "name": "phase transition", "size": 50,  "children": [] }, { "name": "conflict graph", "size": 50,  "children": [] }, { "name": "CDCL", "size": 50,  "children": [] }, { "name": "learned clause", "size": 50,  "children": [] }, { "name": "conflict literal", "size": 50,  "children": [] }, { "name": "implied literal", "size": 50,  "children": [] }, { "name": "critical value", "size": 50,  "children": [] }, { "name": "clause learning", "size": 50,  "children": [] }, { "name": "choice literal", "size": 50,  "children": [] }, { "name": "conflict vertex", "size": 50,  "children": [] }, ] }, { "name": "SNDforallE", "size": 50,  "children": [] }, { "name": "RDFalanguage", "size": 50,  "children": [] }, { "name": "universal quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "SAT", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "unitary", "size": 50,  "children": [] }, { "name": "completeness", "size": 50,  "children": [] }, { "name": "linearized notation for sequent-style ND proofs", "size": 50,  "children": [] }, { "name": "falsifies", "size": 50,  "children": [] }, { "name": "definiendum", "size": 50,  "children": [] }, { "name": "resource", "size": 50,  "children": [] }, { "name": "falsified", "size": 50, "color": "red",  "children": [] }, { "name": "NDforallI", "size": 50,  "children": [] }, { "name": "krInter", "size": 50,  "children": [] }, { "name": "disjunction", "size": 50, "color": "lightred",  "children": [] }, { "name": "conjunction introduction", "size": 50,  "children": [] }, { "name": "even", "size": 50,  "children": [] }, { "name": "realization", "size": 50,  "children": [] }, { "name": "inference", "size": 50, "color": "red",  "children": [] }, { "name": "false elimination", "size": 50,  "children": [] }, { "name": "DAG solved form", "size": 50,  "children": [] }, { "name": "implication introduction", "size": 50,  "children": [] }, { "name": "ontology system", "size": 50,  "children": [] }, { "name": "negative", "size": 50, "color": "lightred",  "children": [] }, { "name": "ATPer", "size": 50,  "children": [] }, { "name": "Wumpus world", "size": 50,  "children": [] }, { "name": "NDorIR", "size": 50,  "children": [] }, { "name": "position", "size": 50,  "children": [] }, { "name": "reasonable", "size": 50,  "children": [] }, { "name": "semantics", "size": 50,  "children": [] }, { "name": "interpretation", "size": 50, "color": "red",  "children": [] }, { "name": "satisfiable in", "size": 50,  "children": [] }, { "name": "ALCTcaxRule", "size": 50,  "children": [] }, { "name": "SPARQL", "size": 50,  "children": [] }, { "name": "funcarg", "size": 50,  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "substeq", "size": 50,  "children": [] }, { "name": "ontology web language", "size": 50,  "children": [] }, { "name": "RDF", "size": 50,  "children": [] }, { "name": "plus", "size": 50,  "children": [] }, { "name": "alphabetical variant", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, { "name": "disjunction introduction left", "size": 50,  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "testunsat", "size": 50,  "children": [] }, { "name": "PropCNF", "size": 50,  "children": [] }, { "name": "initial", "size": 50,  "children": [] }, { "name": "clause", "size": 50, "color": "red",  "children": [] }, { "name": "NDexistsE", "size": 50,  "children": [] }, { "name": "ALCTcutRule", "size": 50,  "children": [] }, { "name": "NDhyp", "size": 50,  "children": [] }, { "name": "tableau proof", "size": 50,  "children": [] }, { "name": "SNDforallI", "size": 50,  "children": [] }, { "name": "ALCT functional", "size": 50,  "children": [] }, { "name": "complete", "size": 50, "color": "red",  "children": [] }, { "name": "gt", "size": 50,  "children": [] }, { "name": "description logic", "size": 50,  "children": [] }, { "name": "sinvalid", "size": 50,  "children": [] }, { "name": "complete", "size": 50,  "children": [] }, { "name": "triple", "size": 50,  "children": [] }, { "name": "more general", "size": 50,  "children": [] }, { "name": "order parameter", "size": 50,  "children": [] }, { "name": "ALCexists", "size": 50,  "children": [] }, { "name": "saturate", "size": 50,  "children": [] }, { "name": "functional syntax", "size": 50,  "children": [] }, { "name": "FOUtriv", "size": 50,  "children": [] }, { "name": "domain of discourse", "size": 50,  "children": [] }, { "name": "unification problem", "size": 50,  "children": [] }, { "name": "SNDequivE", "size": 50,  "children": [] }, { "name": "NNF", "size": 50,  "children": [] }, { "name": "tabor", "size": 50,  "children": [] }, { "name": "PLT", "size": 50,  "children": [] }, { "name": "labeled formula", "size": 50, "color": "red",  "children": [] }, { "name": "discharge", "size": 50, "color": "lightred",  "children": [] }, { "name": "splitting", "size": 50,  "children": [] }, { "name": "contradiction", "size": 50,  "children": [] }, { "name": "worked off", "size": 50,  "children": [] }, { "name": "abstract consistency class", "size": 50,  "children": [] }, { "name": "ALCTexistsRule", "size": 50,  "children": [] }, { "name": "top concept", "size": 50,  "children": [] }, { "name": "normalized", "size": 50,  "children": [] }, { "name": "hasatpos", "size": 50,  "children": [] }, { "name": "bound", "size": 50,  "children": [] }, { "name": "true", "size": 50,  "children": [] }, { "name": "inst link", "size": 50,  "children": [] }, { "name": "unit clause", "size": 50,  "children": [] }, { "name": "fact clause", "size": 50,  "children": [] }, { "name": "alc semantics", "size": 50,  "children": [] }, { "name": "taband", "size": 50,  "children": [] }, { "name": "CNF", "size": 50, "color": "orange",  "children": [] }, { "name": "extension", "size": 50,  "children": [] }, { "name": "valid under", "size": 50,  "children": [] }, { "name": "hintstar", "size": 50,  "children": [] }, { "name": "krConcept", "size": 50,  "children": [] }, { "name": "relation", "size": 50, "color": "red",  "children": [] }, { "name": "critical value", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "ALCTclosed", "size": 50,  "children": [] }, { "name": "value function", "size": 50, "color": "red",  "children": [] }, { "name": "prove", "size": 50,  "children": [] }, { "name": "HornCalc", "size": 50,  "children": [] }, { "name": "choice literal", "size": 50,  "children": [] }, { "name": "positive", "size": 50, "color": "lightred",  "children": [] }, { "name": "FOLEQNDCalc", "size": 50,  "children": [] }, { "name": "occurrence", "size": 50,  "children": [] }, { "name": "proof", "size": 50,  "children": [] }, { "name": "SNDexistsE", "size": 50,  "children": [] }, { "name": "evaluation criteria", "size": 50,  "children": [] }, { "name": "derivation relation", "size": 50,  "children": [] }, { "name": "derivable", "size": 50, "color": "red",  "children": [] }, { "name": "KAxiom", "size": 50,  "children": [] }, { "name": "disjunction elimination", "size": 50,  "children": [] }, { "name": "conjunction elimination right", "size": 50,  "children": [] }, { "name": "capture-avoiding", "size": 50,  "children": [] }, { "name": "refute", "size": 50,  "children": [] }, { "name": "nderives", "size": 50,  "children": [] }, { "name": "link", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "isa link", "size": 50,  "children": [] }, { "name": "satisfiable", "size": 50, "color": "red",  "children": [] }, { "name": "CDCL", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "validin", "size": 50, "color": "red",  "children": [] }, { "name": "conflict vertex", "size": 50,  "children": [] }, { "name": "proof reflexive", "size": 50,  "children": [] }, { "name": "conclusion", "size": 50, "color": "red",  "children": [] }, { "name": "satisfiable", "size": 50,  "children": [] }, { "name": "hintand", "size": 50,  "children": [] }, { "name": "extend", "size": 50,  "children": [] }, { "name": "closed", "size": 50,  "children": [] }, { "name": "ALCInter", "size": 50,  "children": [] }, { "name": "clauseset iso", "size": 50,  "children": [] }, { "name": "implied literal", "size": 50,  "children": [] }, { "name": "complex", "size": 50, "color": "lightred",  "children": [] }, { "name": "negation", "size": 50, "color": "orange",  "children": [] }, { "name": "svalid", "size": 50,  "children": [] }, { "name": "FOLEQ", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "resolvent", "size": 50,  "children": [] }, { "name": "absexists", "size": 50,  "children": [] }, { "name": "NDorIL", "size": 50,  "children": [] }, { "name": "assertion", "size": 50,  "children": [] }, { "name": "individual", "size": 50, "color": "red",  "children": [] }, { "name": "closed under subsets", "size": 50,  "children": [] }, { "name": "DPLL", "size": 50,  "children": [] }, { "name": "rclausesetext", "size": 50,  "children": [] }, { "name": "conflict literal", "size": 50,  "children": [] }, { "name": "gold", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "judgment", "size": 50,  "children": [] }, { "name": "calculus", "size": 50, "color": "red",  "children": [] }, { "name": "Horn clause", "size": 50,  "children": [] }, { "name": "nabla HS", "size": 50,  "children": [] }, { "name": "NDaxiom", "size": 50,  "children": [] }, { "name": "derived", "size": 50,  "children": [] }, { "name": "NDnegI", "size": 50,  "children": [] }, { "name": "UP", "size": 50,  "children": [] }, { "name": "derive", "size": 50,  "children": [] }, { "name": "rule clause", "size": 50,  "children": [] }, { "name": "propSNDcalc", "size": 50,  "children": [] }, { "name": "solved variable", "size": 50,  "children": [] }, { "name": "hypothesis", "size": 50, "color": "red",  "children": [] }, { "name": "individual variable", "size": 50, "color": "red",  "children": [] }, { "name": "conjecture", "size": 50,  "children": [] }, { "name": "implication introduction", "size": 50,  "children": [] }, { "name": "equivalent", "size": 50,  "children": [] }, { "name": "conjunction elimination right", "size": 50,  "children": [] }, { "name": "equals", "size": 50,  "children": [] }, { "name": "subject", "size": 50,  "children": [] }, { "name": "succ", "size": 50,  "children": [] }, { "name": "theorem", "size": 50, "color": "red",  "children": [] }, { "name": "FOUDagCalc", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "Wumpus", "size": 50,  "children": [] }, { "name": "tabclose", "size": 50,  "children": [] }, { "name": "invalidin", "size": 50, "color": "red",  "children": [] }, { "name": "implication elimination", "size": 50,  "children": [] }, { "name": "satisfaction relation", "size": 50, "color": "red",  "children": [] }, { "name": "first-order CNF calculus", "size": 50,  "children": [] }, { "name": "subsume", "size": 50,  "children": [] }, { "name": "DNF", "size": 50, "color": "lightred",  "children": [] }, { "name": "ALCsatisfies", "size": 50,  "children": [] }, { "name": "refutable", "size": 50,  "children": [] }, { "name": "clause set simplification", "size": 50,  "children": [] }, { "name": "concept axiom", "size": 50, "color": "red",  "children": [] }, { "name": "entails", "size": 50,  "children": [] }, { "name": "HintikkaSet", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "WfUni", "size": 50,  "children": [] }, { "name": "satisfied", "size": 50, "color": "red",  "children": [] }, { "name": "axiom", "size": 50, "color": "red",  "children": [] }, { "name": "multiplicity", "size": 50,  "children": [] }, { "name": "termmeasure", "size": 50,  "children": [] }, { "name": "sbstListdots", "size": 50,  "children": [] }, { "name": "negative", "size": 50,  "children": [] }, { "name": "theorem proving", "size": 50,  "children": [] }, { "name": "modus ponens", "size": 50,  "children": [] }, { "name": "flang", "size": 50, "color": "red",  "children": [] }, { "name": "Skolem constant", "size": 50, "color": "red",  "children": [] }, { "name": "opposite literal", "size": 50,  "children": [] }, { "name": "test calculus", "size": 50,  "children": [] }, { "name": "clause learning", "size": 50,  "children": [] }, { "name": "infruledef", "size": 50,  "children": [] }, { "name": "tabnegtrue", "size": 50,  "children": [] }, { "name": "dlcdef", "size": 50,  "children": [] }, { "name": "ALCforall", "size": 50,  "children": [] }, { "name": "primitive", "size": 50,  "children": [] }, { "name": "unifier", "size": 50,  "children": [] }, { "name": "FOUdec", "size": 50,  "children": [] }, { "name": "ATP", "size": 50,  "children": [] }, { "name": "ALCFormulae", "size": 50,  "children": [] }, { "name": "FOUelim", "size": 50,  "children": [] }, { "name": "sbstEqOn", "size": 50,  "children": [] }, { "name": "disjunction introduction right", "size": 50,  "children": [] }, { "name": "consistent", "size": 50,  "children": [] }, { "name": "reducible", "size": 50,  "children": [] }, { "name": "equivalence", "size": 50,  "children": [] }, { "name": "ontology", "size": 50, "color": "red",  "children": [] }, { "name": "deduction", "size": 50,  "children": [] }, { "name": "ABoxInd", "size": 50,  "children": [] }, { "name": "absc", "size": 50,  "children": [] }, { "name": "FOUniverse", "size": 50,  "children": [] }, { "name": "NDfalseI", "size": 50,  "children": [] }, { "name": "falsifiable", "size": 50, "color": "red",  "children": [] }, { "name": "TBox", "size": 50,  "children": [] }, { "name": "solved pair", "size": 50,  "children": [] }, { "name": "mrclause", "size": 50,  "children": [] }, { "name": "semival", "size": 50,  "children": [] }, { "name": "entails", "size": 50, "color": "red",  "children": [] }, { "name": "sound", "size": 50, "color": "red",  "children": [] }, { "name": "semantic network", "size": 50,  "children": [] }, { "name": "NDeqI", "size": 50,  "children": [] }, { "name": "logic program", "size": 50,  "children": [] }, { "name": "role", "size": 50,  "children": [] }, { "name": "inference rule", "size": 50, "color": "red",  "children": [] }, { "name": "sbst", "size": 50,  "children": [] }, { "name": "multiset ordering", "size": 50,  "children": [] }, { "name": "logical constant", "size": 50, "color": "red",  "children": [] }, { "name": "clause iso", "size": 50,  "children": [] }, { "name": "answer substitution", "size": 50,  "children": [] }, { "name": "ABox", "size": 50,  "children": [] }, { "name": "proposition", "size": 50, "color": "red",  "children": [] }, { "name": "existential quantifier", "size": 50, "color": "red",  "children": [] }, { "name": "proof transitive", "size": 50,  "children": [] }, { "name": "resolution proof", "size": 50,  "children": [] }, { "name": "atomic", "size": 50, "color": "orange",  "children": [] }, { "name": "tertium non datur", "size": 50,  "children": [] }, { "name": "ALCTunionRule", "size": 50,  "children": [] }, { "name": "termweight", "size": 50,  "children": [] }, { "name": "object", "size": 50, "color": "red",  "children": [] }, { "name": "FOUDagevar", "size": 50,  "children": [] }, { "name": "conflict graph", "size": 50,  "children": [] }, { "name": "tableau refutation", "size": 50,  "children": [] }, { "name": "frame", "size": 50,  "children": [] }, { "name": "FOTabcut", "size": 50,  "children": [] }, { "name": "mgu", "size": 50,  "children": [] }, { "name": "SNDexistsI", "size": 50,  "children": [] }, { "name": "NDequivI", "size": 50,  "children": [] }, { "name": "falsifiable in", "size": 50,  "children": [] }, { "name": "absstar", "size": 50,  "children": [] }, { "name": "valid in", "size": 50,  "children": [] }, { "name": "multisetorderingOp", "size": 50,  "children": [] }, { "name": "model", "size": 50, "color": "red",  "children": [] }, { "name": "predicate constant", "size": 50, "color": "red",  "children": [] }, { "name": "PLF", "size": 50,  "children": [] }, { "name": "isred", "size": 50,  "children": [] }, { "name": "function constant", "size": 50, "color": "red",  "children": [] }, { "name": "NDfalseE", "size": 50,  "children": [] }, { "name": "learned clause", "size": 50,  "children": [] }, { "name": "concept definition", "size": 50,  "children": [] }, { "name": "false introduction", "size": 50,  "children": [] }, { "name": "rclauseset", "size": 50,  "children": [] }, { "name": "number of decisions", "size": 50,  "children": [] }, { "name": "domaincomplement", "size": 50,  "children": [] }, { "name": "FOTabforall", "size": 50,  "children": [] }, { "name": "implicit", "size": 50,  "children": [] }, { "name": "first-order logic", "size": 50, "color": "red",  "children": [] }, { "name": "bound variable occurrence", "size": 50,  "children": [] }, { "name": "mating", "size": 50,  "children": [] }, { "name": "terminology", "size": 50,  "children": [] }, { "name": "propositional natural deduction calculus", "size": 50,  "children": [] }, { "name": "substitution application", "size": 50,  "children": [] }, { "name": "instance", "size": 50,  "children": [] }, { "name": "formal system", "size": 50, "color": "red",  "children": [] }, { "name": "axiom rule", "size": 50,  "children": [] }, { "name": "instance test", "size": 50,  "children": [] }, { "name": "mrclauseCollection", "size": 50,  "children": [] }, { "name": "abduction", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "replace", "size": 50,  "children": [] }, { "name": "FOUnifCalc", "size": 50,  "children": [] }, { "name": "classical ontology", "size": 50,  "children": [] }, { "name": "nodelabel", "size": 50,  "children": [] }, { "name": "conjunction introduction", "size": 50,  "children": [] }, { "name": "unifiable", "size": 50,  "children": [] }, { "name": "intersection", "size": 50,  "children": [] }, { "name": "absor", "size": 50,  "children": [] }, { "name": "discharge", "size": 50,  "children": [] }, { "name": "theta compatible", "size": 50,  "children": [] }, { "name": "SNDeqI", "size": 50,  "children": [] }, { "name": "instance assertion", "size": 50,  "children": [] }, { "name": "assumption", "size": 50, "color": "red",  "children": [] }, { "name": "solved form", "size": 50,  "children": [] }, { "name": "script", "size": 50,  "children": [] }, { "name": "sequent", "size": 50,  "children": [] }, { "name": "RDF graph", "size": 50,  "children": [] }, { "name": "conjunction elimination left", "size": 50,  "children": [] }, { "name": "GSAT algorithm", "size": 50,  "children": [] }, { "name": "role assertion", "size": 50,  "children": [] }, { "name": "absforall", "size": 50,  "children": [] }, { "name": "first-order CNF", "size": 50,  "children": [] }, { "name": "proposition", "size": 50,  "children": [] }, { "name": "derive", "size": 50, "color": "red",  "children": [] }, { "name": "universe", "size": 50, "color": "red",  "children": [] }, { "name": "free variable tableau calculus", "size": 50,  "children": [] }, { "name": "deduction", "size": 50,  "children": [] }, { "name": "sbstInstOrRel", "size": 50,  "children": [] }, { "name": "tabcut", "size": 50,  "children": [] }, { "name": "FOUDagmerge", "size": 50,  "children": [] }, { "name": "SAT problem", "size": 50,  "children": [] }, { "name": "ALCT", "size": 50,  "children": [] }, { "name": "normalization", "size": 50,  "children": [] }, { "name": "truth value", "size": 50, "color": "red",  "children": [] }, { "name": "monotonic", "size": 50,  "children": [] }, { "name": "eqsubst", "size": 50,  "children": [] }, { "name": "phase transition", "size": 50,  "children": [] }, { "name": "expressive adequacy", "size": 50,  "children": [] }, { "name": "unsatisfiable", "size": 50, "color": "red",  "children": [] }, { "name": "weakening", "size": 50,  "children": [] }, { "name": "classification", "size": 50,  "children": [] }, { "name": "Hilbert calculus", "size": 50,  "children": [] }, { "name": "logical system", "size": 50, "color": "red",  "children": [] }, { "name": "subsumption test", "size": 50,  "children": [] }, { "name": "NDeqE", "size": 50,  "children": [] }, { "name": "expression", "size": 50, "color": "red",  "children": [] }, { "name": "rclausesetunion", "size": 50,  "children": [] }, { "name": "SPARQL endpoint", "size": 50,  "children": [] }, { "name": "tree resolution", "size": 50,  "children": [] }, { "name": "PropCNFCalc", "size": 50,  "children": [] }, { "name": "formula", "size": 50, "color": "red",  "children": [] }, { "name": "pair", "size": 50,  "children": [] }, { "name": "Horn logic", "size": 50,  "children": [] }, { "name": "connective", "size": 50, "color": "red",  "children": [] }, { "name": "ALCTintersRule", "size": 50,  "children": [] }, { "name": "bottom concept", "size": 50,  "children": [] }, { "name": "literal", "size": 50, "color": "red",  "children": [] }, { "name": "complement", "size": 50,  "children": [] }, { "name": "conjunction elimination left", "size": 50,  "children": [] }, { "name": "first-order sequent calculus", "size": 50,  "children": [] }, { "name": "testcompl", "size": 50,  "children": [] }, { "name": "first-order resolution calculus", "size": 50,  "children": [] }, { "name": "negation elimination", "size": 50,  "children": [] }, { "name": "sunion", "size": 50,  "children": [] }, { "name": "compact", "size": 50,  "children": [] }, { "name": "sFOTabforall", "size": 50,  "children": [] }, { "name": "absneg", "size": 50,  "children": [] }, { "name": "domain", "size": 50,  "children": [] }, { "name": "semantic web", "size": 50,  "children": [] }, { "name": "PropTabCalc", "size": 50,  "children": [] }, { "name": "infruleref", "size": 50,  "children": [] }, { "name": "implication", "size": 50, "color": "red",  "children": [] }, { "name": "definiens", "size": 50,  "children": [] }, { "name": "calc", "size": 50, "color": "red",  "children": [] }, { "name": "ALC", "size": 50,  "children": [] }, { "name": "implication elimination", "size": 50,  "children": [] }, { "name": "syntax", "size": 50,  "children": [] }, { "name": "union", "size": 50,  "children": [] }, { "name": "substitution rule", "size": 50,  "children": [] }, { "name": "unification", "size": 50,  "children": [] }, { "name": "modcls", "size": 50, "color": "red",  "children": [] }, { "name": "meta representation", "size": 50,  "children": [] }, { "name": "logic-based agent", "size": 50,  "children": [] }, { "name": "acyclic", "size": 50,  "children": [] }, { "name": "resolution calculus", "size": 50,  "children": [] }, { "name": "sbstInstOr", "size": 50,  "children": [] }, { "name": "propositional variable", "size": 50, "color": "red",  "children": [] }, { "name": "sentence", "size": 50,  "children": [] }, { "name": "open", "size": 50,  "children": [] }, { "name": "correct", "size": 50,  "children": [] }, { "name": "labeled formulae", "size": 50,  "children": [] }, { "name": "isblock", "size": 50,  "children": [] }, { "name": "unsatisfiable in", "size": 50,  "children": [] }, { "name": "first-order signature", "size": 50, "color": "red",  "children": [] }, { "name": "empty clause", "size": 50,  "children": [] }, { "name": "reasoning efficiency", "size": 50,  "children": [] }, { "name": "hypothetical reasoning", "size": 50,  "children": [] }, { "name": "property value", "size": 50,  "children": [] }, { "name": "refutation", "size": 50,  "children": [] }, { "name": "implication graph", "size": 50,  "children": [] }, { "name": "recursive", "size": 50,  "children": [] }, { "name": "ALCTforallRule", "size": 50,  "children": [] }, { "name": "tertium non datur", "size": 50,  "children": [] }, { "name": "literal", "size": 50, "color": "lightred",  "children": [] }, { "name": "propUniverse", "size": 50,  "children": [] }, { "name": "DL reasoner", "size": 50,  "children": [] }, { "name": "absand", "size": 50,  "children": [] }, { "name": "property", "size": 50,  "children": [] }, { "name": "sbstList", "size": 50,  "children": [] }, { "name": "conjunct", "size": 50, "color": "red",  "children": [] }, { "name": "PLNQ", "size": 50,  "children": [] }, { "name": "NDforallE", "size": 50,  "children": [] }, { "name": "FOTabexists", "size": 50,  "children": [] }, { "name": "term", "size": 50, "color": "red",  "children": [] }, { "name": "free", "size": 50,  "children": [] }, { "name": "hintneg", "size": 50,  "children": [] }, { "name": "equivalence", "size": 50, "color": "red",  "children": [] }, { "name": "tableau", "size": 50,  "children": [] }, { "name": "concept", "size": 50, "color": "red",  "children": [] }, { "name": "positive", "size": 50,  "children": [] }, { "name": "conjunction", "size": 50, "color": "lightred",  "children": [] }, { "name": "cut literal", "size": 50,  "children": [] }, { "name": "substitution", "size": 50,  "children": [] }, { "name": "variable assignment", "size": 50,  "children": [] }, { "name": "derivation tree", "size": 50, "color": "red",  "children": [] }, { "name": "hintforall", "size": 50,  "children": [] }, { "name": "UR", "size": 50,  "children": [] }, { "name": "clause set", "size": 50,  "children": [] }, { "name": "assignment", "size": 50,  "children": [] }, { "name": "valid", "size": 50, "color": "red",  "children": [] }, { "name": "FONDCalc", "size": 50,  "children": [] }, { "name": "disjunct", "size": 50, "color": "lightred",  "children": [] }, { "name": "SNDequivI", "size": 50,  "children": [] }, { "name": "tabnegfalse", "size": 50,  "children": [] }, { "name": "hintc", "size": 50,  "children": [] }, { "name": "hintexists", "size": 50,  "children": [] }, { "name": "at position", "size": 50,  "children": [] }, { "name": "pit", "size": 50,  "children": [] }, { "name": "negation introduction", "size": 50,  "children": [] }, { "name": "resolve", "size": 50,  "children": [] }, { "name": "object", "size": 50,  "children": [] }, { "name": "dl ontology", "size": 50,  "children": [] }, { "name": "local hypothesis", "size": 50,  "children": [] }, { "name": "SNDeqE", "size": 50,  "children": [] }, { "name": "support", "size": 50,  "children": [] }, { "name": "primitives", "size": 50,  "children": [] }, { "name": "NDequivE", "size": 50,  "children": [] }, { "name": "mrclauseProp", "size": 50,  "children": [] }, { "name": "standard tableau calculus", "size": 50,  "children": [] }, { "name": "SAT solver", "size": 50,  "children": [] }, { "name": "derivation", "size": 50, "color": "lightred",  "children": [] }, { "name": "invalid", "size": 50,  "children": [] }, { "name": "hintor", "size": 50,  "children": [] }, { "name": "admissible", "size": 50,  "children": [] }, { "name": "ALT", "size": 50,  "children": [] }, { "name": "formula", "size": 50, "color": "lightred",  "children": [] }, { "name": "triplestore", "size": 50,  "children": [] }, { "name": "empty substitution", "size": 50,  "children": [] }, { "name": "satisfies", "size": 50,  "children": [] }, { "name": "opposite literal", "size": 50,  "children": [] }, { "name": "induction", "size": 50,  "children": [] }, { "name": "SAxiom", "size": 50,  "children": [] }, { "name": "sFOTabexists", "size": 50,  "children": [] }, { "name": "assertions", "size": 50,  "children": [] }, { "name": "NDexistsI", "size": 50,  "children": [] }, { "name": "NDorE", "size": 50,  "children": [] }, { "name": "propositional logic", "size": 50, "color": "red",  "children": [] }, { "name": "spanning mating", "size": 50,  "children": [] }, { "name": "resolution rule", "size": 50,  "children": [] }, { "name": "power", "size": 50,  "children": [] }, { "name": "NDnegE", "size": 50,  "children": [] }, { "name": "sbstListfromto", "size": 50,  "children": [] }, { "name": "PropDL", "size": 50,  "children": [] }, { "name": "query", "size": 50, "color": "red",  "children": [] }, { "name": "consistency test", "size": 50,  "children": [] }, { "name": "cell", "size": 50,  "children": [] }, ] }, { "name": "Planning & Acting", "size": 50, "children": [{ "name": "Planning II: Algorithms", "size": 50, "children": [{ "name": "The Delete Relaxation", "size": 50, "children": [{ "name": "delete-relaxed", "size": 50,  "children": [] }, { "name": "delreldel", "size": 50,  "children": [] }, { "name": "delreladd", "size": 50,  "children": [] }, { "name": "delrel", "size": 50,  "children": [] }, { "name": "delrelpre", "size": 50,  "children": [] }, { "name": "delete relaxation", "size": 50,  "children": [] }, { "name": "relaxed plan", "size": 50,  "children": [] }, { "name": "PlanExPlus", "size": 50,  "children": [] }, ] }, { "name": "Conclusion", "size": 50, "children": [] }, { "name": "Introduction", "size": 50, "children": [{ "name": "heuristic", "size": 50,  "children": [] }, { "name": "real cost", "size": 50,  "children": [] }, ] }, { "name": "The ?Heuristic", "size": 50, "children": [{ "name": "ideal delete relaxation heuristic", "size": 50,  "children": [] }, { "name": "hplus", "size": 50,  "children": [] }, { "name": "optimal relaxed plan", "size": 50,  "children": [] }, ] }, { "name": "How to Relax in Planning", "size": 50, "children": [{ "name": "realcostinFN", "size": 50,  "children": [] }, { "name": "relaxation mapping", "size": 50,  "children": [] }, { "name": "relaxed planning", "size": 50,  "children": [] }, { "name": "perfect heuristic", "size": 50,  "children": [] }, ] }, { "name": "optimal relaxed plan", "size": 50,  "children": [] }, { "name": "ideal delete relaxation heuristic", "size": 50,  "children": [] }, { "name": "relaxation mapping", "size": 50,  "children": [] }, { "name": "delrelpre", "size": 50,  "children": [] }, { "name": "realcostinFN", "size": 50,  "children": [] }, { "name": "hplus", "size": 50,  "children": [] }, { "name": "delete-relaxed", "size": 50,  "children": [] }, { "name": "perfect heuristic", "size": 50,  "children": [] }, { "name": "heuristic", "size": 50,  "children": [] }, { "name": "delreldel", "size": 50,  "children": [] }, { "name": "delrel", "size": 50,  "children": [] }, { "name": "delreladd", "size": 50,  "children": [] }, { "name": "delete relaxation", "size": 50,  "children": [] }, { "name": "relaxed planning", "size": 50,  "children": [] }, { "name": "relaxed plan", "size": 50,  "children": [] }, { "name": "real cost", "size": 50,  "children": [] }, { "name": "PlanExPlus", "size": 50,  "children": [] }, ] }, { "name": "Planning I: Framework", "size": 50, "children": [{ "name": "Conclusion", "size": 50, "children": [] }, { "name": "The PDDL Language", "size": 50, "children": [{ "name": "PDDL", "size": 50,  "children": [] }, { "name": "benchmark", "size": 50,  "children": [] }, { "name": "domain file", "size": 50,  "children": [] }, { "name": "problem file", "size": 50,  "children": [] }, { "name": "object variable", "size": 50,  "children": [] }, { "name": "action schema", "size": 50,  "children": [] }, { "name": "PDDL planning task", "size": 50,  "children": [] }, { "name": "object", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, ] }, { "name": "Planning: Introduction", "size": 50, "children": [{ "name": "planning", "size": 50,  "children": [] }, { "name": "plan", "size": 50,  "children": [] }, { "name": "satisficing planning", "size": 50,  "children": [] }, { "name": "planning language", "size": 50,  "children": [] }, { "name": "optimal plan", "size": 50,  "children": [] }, { "name": "effect", "size": 50,  "children": [] }, { "name": "optimal planning", "size": 50,  "children": [] }, { "name": "planner", "size": 50,  "children": [] }, { "name": "planning task", "size": 50,  "children": [] }, { "name": "precondition", "size": 50,  "children": [] }, ] }, { "name": "Logic-Based Planning", "size": 50, "children": [{ "name": "effect axiom", "size": 50,  "children": [] }, { "name": "frame problem", "size": 50,  "children": [] }, { "name": "fluent", "size": 50,  "children": [] }, { "name": "draft", "size": 50,  "children": [] }, { "name": "frame axiom", "size": 50,  "children": [] }, { "name": "atemporal", "size": 50,  "children": [] }, { "name": "end time", "size": 50,  "children": [] }, { "name": "sensor axiom", "size": 50,  "children": [] }, { "name": "frame of reference", "size": 50,  "children": [] }, ] }, { "name": "The History of Planning", "size": 50, "children": [{ "name": "Sussman anomaly", "size": 50,  "children": [] }, { "name": "IPC", "size": 50,  "children": [] }, ] }, { "name": "Partial Order Planning", "size": 50, "children": [{ "name": "promotion", "size": 50,  "children": [] }, { "name": "start step", "size": 50,  "children": [] }, { "name": "Sussman anomaly", "size": 50,  "children": [] }, { "name": "complete", "size": 50,  "children": [] }, { "name": "step", "size": 50,  "children": [] }, { "name": "partially ordered plan", "size": 50,  "children": [] }, { "name": "choice point", "size": 50,  "children": [] }, { "name": "achieve", "size": 50,  "children": [] }, { "name": "add link", "size": 50,  "children": [] }, { "name": "order", "size": 50,  "children": [] }, { "name": "causal link", "size": 50,  "children": [] }, { "name": "temporal constraint", "size": 50,  "children": [] }, { "name": "systematic", "size": 50,  "children": [] }, { "name": "stripsop", "size": 50,  "children": [] }, { "name": "demotion", "size": 50,  "children": [] }, { "name": "open condition", "size": 50,  "children": [] }, { "name": "POP", "size": 50,  "children": [] }, { "name": "finish step", "size": 50,  "children": [] }, { "name": "add step", "size": 50,  "children": [] }, { "name": "possibly intervening", "size": 50,  "children": [] }, { "name": "partial order planning", "size": 50,  "children": [] }, { "name": "clobber", "size": 50,  "children": [] }, ] }, { "name": "The STRIPS Planning Formalism", "size": 50, "children": [{ "name": "stripsapply", "size": 50,  "children": [] }, { "name": "stripsindSP", "size": 50,  "children": [] }, { "name": "plan", "size": 50,  "children": [] }, { "name": "goal state", "size": 50,  "children": [] }, { "name": "delete list", "size": 50,  "children": [] }, { "name": "add list", "size": 50,  "children": [] }, { "name": "fact", "size": 50,  "children": [] }, { "name": "onTable", "size": 50,  "children": [] }, { "name": "holdingblock", "size": 50,  "children": [] }, { "name": "putdownblock", "size": 50,  "children": [] }, { "name": "blocks world", "size": 50,  "children": [] }, { "name": "visited", "size": 50,  "children": [] }, { "name": "unstackblock", "size": 50,  "children": [] }, { "name": "facts", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "Brisbane", "size": 50,  "children": [] }, { "name": "stripstrans", "size": 50,  "children": [] }, { "name": "iamat", "size": 50,  "children": [] }, { "name": "stripstransition", "size": 50,  "children": [] }, { "name": "initial state", "size": 50,  "children": [] }, { "name": "Adelaide", "size": 50,  "children": [] }, { "name": "goal state", "size": 50,  "children": [] }, { "name": "blockon", "size": 50,  "children": [] }, { "name": "Sydney", "size": 50,  "children": [] }, { "name": "solvable", "size": 50,  "children": [] }, { "name": "stripsstates", "size": 50,  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "STRIPS task", "size": 50,  "children": [] }, { "name": "armEmpty", "size": 50,  "children": [] }, { "name": "applicable", "size": 50,  "children": [] }, { "name": "stripsgoalstates", "size": 50,  "children": [] }, { "name": "stackblock", "size": 50,  "children": [] }, { "name": "STRIPS", "size": 50,  "children": [] }, { "name": "preconditions", "size": 50,  "children": [] }, { "name": "blockclear", "size": 50,  "children": [] }, { "name": "Perth", "size": 50,  "children": [] }, { "name": "induced", "size": 50,  "children": [] }, { "name": "pickupblock", "size": 50,  "children": [] }, { "name": "Darwin", "size": 50,  "children": [] }, { "name": "drive", "size": 50,  "children": [] }, ] }, { "name": "start step", "size": 50,  "children": [] }, { "name": "goal state", "size": 50,  "children": [] }, { "name": "add list", "size": 50,  "children": [] }, { "name": "object variable", "size": 50,  "children": [] }, { "name": "atemporal", "size": 50,  "children": [] }, { "name": "optimal plan", "size": 50,  "children": [] }, { "name": "fact", "size": 50,  "children": [] }, { "name": "step", "size": 50,  "children": [] }, { "name": "action schema", "size": 50,  "children": [] }, { "name": "choice point", "size": 50,  "children": [] }, { "name": "holdingblock", "size": 50,  "children": [] }, { "name": "sensor axiom", "size": 50,  "children": [] }, { "name": "order", "size": 50,  "children": [] }, { "name": "planning task", "size": 50,  "children": [] }, { "name": "visited", "size": 50,  "children": [] }, { "name": "systematic", "size": 50,  "children": [] }, { "name": "facts", "size": 50,  "children": [] }, { "name": "stripsop", "size": 50,  "children": [] }, { "name": "open condition", "size": 50,  "children": [] }, { "name": "planning language", "size": 50,  "children": [] }, { "name": "Brisbane", "size": 50,  "children": [] }, { "name": "finish step", "size": 50,  "children": [] }, { "name": "end time", "size": 50,  "children": [] }, { "name": "stripstransition", "size": 50,  "children": [] }, { "name": "initial state", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "promotion", "size": 50,  "children": [] }, { "name": "frame axiom", "size": 50,  "children": [] }, { "name": "Sussman anomaly", "size": 50,  "children": [] }, { "name": "goal state", "size": 50,  "children": [] }, { "name": "blockon", "size": 50,  "children": [] }, { "name": "solvable", "size": 50,  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "achieve", "size": 50,  "children": [] }, { "name": "armEmpty", "size": 50,  "children": [] }, { "name": "stripsgoalstates", "size": 50,  "children": [] }, { "name": "PDDL planning task", "size": 50,  "children": [] }, { "name": "STRIPS", "size": 50,  "children": [] }, { "name": "planning", "size": 50,  "children": [] }, { "name": "effect axiom", "size": 50,  "children": [] }, { "name": "satisficing planning", "size": 50,  "children": [] }, { "name": "induced", "size": 50,  "children": [] }, { "name": "pickupblock", "size": 50,  "children": [] }, { "name": "possibly intervening", "size": 50,  "children": [] }, { "name": "clobber", "size": 50,  "children": [] }, { "name": "stripsapply", "size": 50,  "children": [] }, { "name": "benchmark", "size": 50,  "children": [] }, { "name": "plan", "size": 50,  "children": [] }, { "name": "domain file", "size": 50,  "children": [] }, { "name": "stripsindSP", "size": 50,  "children": [] }, { "name": "delete list", "size": 50,  "children": [] }, { "name": "frame problem", "size": 50,  "children": [] }, { "name": "problem file", "size": 50,  "children": [] }, { "name": "optimal planning", "size": 50,  "children": [] }, { "name": "onTable", "size": 50,  "children": [] }, { "name": "partially ordered plan", "size": 50,  "children": [] }, { "name": "object", "size": 50,  "children": [] }, { "name": "putdownblock", "size": 50,  "children": [] }, { "name": "blocks world", "size": 50,  "children": [] }, { "name": "temporal constraint", "size": 50,  "children": [] }, { "name": "PDDL", "size": 50,  "children": [] }, { "name": "unstackblock", "size": 50,  "children": [] }, { "name": "declarative description", "size": 50,  "children": [] }, { "name": "POP", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "stripstrans", "size": 50,  "children": [] }, { "name": "iamat", "size": 50,  "children": [] }, { "name": "effect", "size": 50,  "children": [] }, { "name": "Adelaide", "size": 50,  "children": [] }, { "name": "blackbox description", "size": 50,  "children": [] }, { "name": "complete", "size": 50,  "children": [] }, { "name": "Sydney", "size": 50,  "children": [] }, { "name": "stripsstates", "size": 50,  "children": [] }, { "name": "STRIPS task", "size": 50,  "children": [] }, { "name": "add link", "size": 50,  "children": [] }, { "name": "applicable", "size": 50,  "children": [] }, { "name": "planner", "size": 50,  "children": [] }, { "name": "stackblock", "size": 50,  "children": [] }, { "name": "causal link", "size": 50,  "children": [] }, { "name": "preconditions", "size": 50,  "children": [] }, { "name": "blockclear", "size": 50,  "children": [] }, { "name": "Perth", "size": 50,  "children": [] }, { "name": "IPC", "size": 50,  "children": [] }, { "name": "demotion", "size": 50,  "children": [] }, { "name": "draft", "size": 50,  "children": [] }, { "name": "fluent", "size": 50,  "children": [] }, { "name": "Darwin", "size": 50,  "children": [] }, { "name": "add step", "size": 50,  "children": [] }, { "name": "drive", "size": 50,  "children": [] }, { "name": "problem description language", "size": 50,  "children": [] }, { "name": "partial order planning", "size": 50,  "children": [] }, { "name": "precondition", "size": 50,  "children": [] }, { "name": "frame of reference", "size": 50,  "children": [] }, ] }, { "name": "Searching, Planning, and Acting in the Real World", "size": 50, "children": [{ "name": "The Furniture Coloring Example", "size": 50, "children": [] }, { "name": "Searching/Planning with Observation", "size": 50, "children": [{ "name": "contingent planning", "size": 50,  "children": [] }, { "name": "prediction", "size": 50,  "children": [] }, { "name": "update", "size": 50,  "children": [] }, { "name": "ppercepts", "size": 50,  "children": [] }, { "name": "observation prediction", "size": 50,  "children": [] }, { "name": "percepts", "size": 50,  "children": [] }, { "name": "beliefstateprob", "size": 50,  "children": [] }, { "name": "belief state search problem", "size": 50,  "children": [] }, { "name": "result", "size": 50,  "children": [] }, { "name": "plan execution", "size": 50,  "children": [] }, { "name": "contingent plan", "size": 50,  "children": [] }, { "name": "predicted", "size": 50,  "children": [] }, ] }, { "name": "Searching/Planning with Non-Deterministic Actions", "size": 50, "children": [{ "name": "solution", "size": 50,  "children": [] }, { "name": "AND-OR tree", "size": 50,  "children": [] }, { "name": "empty plan", "size": 50,  "children": [] }, { "name": "OR node", "size": 50,  "children": [] }, { "name": "AND node", "size": 50,  "children": [] }, { "name": "while step", "size": 50,  "children": [] }, { "name": "conditional plan", "size": 50,  "children": [] }, { "name": "sub plan", "size": 50,  "children": [] }, { "name": "AND-OR search", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "contingency plan", "size": 50,  "children": [] }, { "name": "conditional step", "size": 50,  "children": [] }, { "name": "AND-OR graph", "size": 50,  "children": [] }, ] }, { "name": "Introduction", "size": 50, "children": [{ "name": "qualification problem", "size": 50,  "children": [] }, ] }, { "name": "Online Search", "size": 50, "children": [{ "name": "dead end", "size": 50,  "children": [] }, { "name": "online search problem", "size": 50,  "children": [] }, { "name": "stepcost", "size": 50,  "children": [] }, { "name": "adversary argument", "size": 50,  "children": [] }, { "name": "offline performance", "size": 50,  "children": [] }, { "name": "goaltest", "size": 50,  "children": [] }, { "name": "online depth first search algorithm", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "safely explorable", "size": 50,  "children": [] }, { "name": "competitive ratio", "size": 50,  "children": [] }, { "name": "irreversible", "size": 50,  "children": [] }, { "name": "online performance", "size": 50,  "children": [] }, ] }, { "name": "Agent Architectures based on Belief States", "size": 50, "children": [{ "name": "transition relation", "size": 50,  "children": [] }, { "name": "transition model", "size": 50,  "children": [] }, { "name": "belief state", "size": 50,  "children": [] }, { "name": "world state", "size": 50,  "children": [] }, { "name": "transition function", "size": 50,  "children": [] }, { "name": "sensor model", "size": 50,  "children": [] }, ] }, { "name": "Replanning and Execution Monitoring", "size": 50, "children": [{ "name": "action monitoring", "size": 50,  "children": [] }, { "name": "plan monitoring", "size": 50,  "children": [] }, { "name": "IPEM", "size": 50,  "children": [] }, { "name": "goal monitoring", "size": 50,  "children": [] }, { "name": "execution monitoring", "size": 50,  "children": [] }, { "name": "replan", "size": 50,  "children": [] }, ] }, { "name": "Searching/Planning without Observations", "size": 50, "children": [{ "name": "sensorless planning", "size": 50,  "children": [] }, ] }, { "name": "online search problem", "size": 50,  "children": [] }, { "name": "AND-OR tree", "size": 50,  "children": [] }, { "name": "stepcost", "size": 50,  "children": [] }, { "name": "adversary argument", "size": 50,  "children": [] }, { "name": "beliefstateprob", "size": 50,  "children": [] }, { "name": "observation prediction", "size": 50,  "children": [] }, { "name": "transition function", "size": 50,  "children": [] }, { "name": "goaltest", "size": 50,  "children": [] }, { "name": "online depth first search algorithm", "size": 50,  "children": [] }, { "name": "transition relation", "size": 50,  "children": [] }, { "name": "transition model", "size": 50,  "children": [] }, { "name": "result", "size": 50,  "children": [] }, { "name": "contingent plan", "size": 50,  "children": [] }, { "name": "predicted", "size": 50,  "children": [] }, { "name": "irreversible", "size": 50,  "children": [] }, { "name": "solution", "size": 50,  "children": [] }, { "name": "sensorless planning", "size": 50,  "children": [] }, { "name": "OR node", "size": 50,  "children": [] }, { "name": "prediction", "size": 50,  "children": [] }, { "name": "contingency plan", "size": 50,  "children": [] }, { "name": "conditional plan", "size": 50,  "children": [] }, { "name": "percepts", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "plan execution", "size": 50,  "children": [] }, { "name": "conditional step", "size": 50,  "children": [] }, { "name": "contingent planning", "size": 50,  "children": [] }, { "name": "empty plan", "size": 50,  "children": [] }, { "name": "update", "size": 50,  "children": [] }, { "name": "AND node", "size": 50,  "children": [] }, { "name": "while step", "size": 50,  "children": [] }, { "name": "action monitoring", "size": 50,  "children": [] }, { "name": "world state", "size": 50,  "children": [] }, { "name": "goal monitoring", "size": 50,  "children": [] }, { "name": "execution monitoring", "size": 50,  "children": [] }, { "name": "competitive ratio", "size": 50,  "children": [] }, { "name": "AND-OR graph", "size": 50,  "children": [] }, { "name": "online performance", "size": 50,  "children": [] }, { "name": "qualification problem", "size": 50,  "children": [] }, { "name": "plan monitoring", "size": 50,  "children": [] }, { "name": "dead end", "size": 50,  "children": [] }, { "name": "offline performance", "size": 50,  "children": [] }, { "name": "sub plan", "size": 50,  "children": [] }, { "name": "ppercepts", "size": 50,  "children": [] }, { "name": "AND-OR search", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "belief state search problem", "size": 50,  "children": [] }, { "name": "safely explorable", "size": 50,  "children": [] }, { "name": "belief state", "size": 50,  "children": [] }, { "name": "IPEM", "size": 50,  "children": [] }, { "name": "replan", "size": 50,  "children": [] }, { "name": "sensor model", "size": 50,  "children": [] }, ] }, { "name": "start step", "size": 50,  "children": [] }, { "name": "AND-OR tree", "size": 50,  "children": [] }, { "name": "add list", "size": 50,  "children": [] }, { "name": "observation prediction", "size": 50,  "children": [] }, { "name": "fact", "size": 50,  "children": [] }, { "name": "transition relation", "size": 50,  "children": [] }, { "name": "contingent plan", "size": 50,  "children": [] }, { "name": "predicted", "size": 50,  "children": [] }, { "name": "holdingblock", "size": 50,  "children": [] }, { "name": "sensor axiom", "size": 50,  "children": [] }, { "name": "order", "size": 50,  "children": [] }, { "name": "irreversible", "size": 50,  "children": [] }, { "name": "hplus", "size": 50,  "children": [] }, { "name": "visited", "size": 50,  "children": [] }, { "name": "solution", "size": 50,  "children": [] }, { "name": "facts", "size": 50,  "children": [] }, { "name": "delete-relaxed", "size": 50,  "children": [] }, { "name": "open condition", "size": 50,  "children": [] }, { "name": "prediction", "size": 50,  "children": [] }, { "name": "planning language", "size": 50,  "children": [] }, { "name": "conditional plan", "size": 50,  "children": [] }, { "name": "Brisbane", "size": 50,  "children": [] }, { "name": "delrel", "size": 50,  "children": [] }, { "name": "percepts", "size": 50,  "children": [] }, { "name": "end time", "size": 50,  "children": [] }, { "name": "stripstransition", "size": 50,  "children": [] }, { "name": "initial state", "size": 50,  "children": [] }, { "name": "PlanExPlus", "size": 50,  "children": [] }, { "name": "promotion", "size": 50,  "children": [] }, { "name": "optimal relaxed plan", "size": 50,  "children": [] }, { "name": "while step", "size": 50,  "children": [] }, { "name": "ideal delete relaxation heuristic", "size": 50,  "children": [] }, { "name": "update", "size": 50,  "children": [] }, { "name": "Sussman anomaly", "size": 50,  "children": [] }, { "name": "relaxation mapping", "size": 50,  "children": [] }, { "name": "blockon", "size": 50,  "children": [] }, { "name": "solvable", "size": 50,  "children": [] }, { "name": "state", "size": 50, "color": "red",  "children": [] }, { "name": "achieve", "size": 50,  "children": [] }, { "name": "armEmpty", "size": 50,  "children": [] }, { "name": "execution monitoring", "size": 50,  "children": [] }, { "name": "stripsgoalstates", "size": 50,  "children": [] }, { "name": "PDDL planning task", "size": 50,  "children": [] }, { "name": "STRIPS", "size": 50,  "children": [] }, { "name": "AND-OR graph", "size": 50,  "children": [] }, { "name": "planning", "size": 50,  "children": [] }, { "name": "effect axiom", "size": 50,  "children": [] }, { "name": "satisficing planning", "size": 50,  "children": [] }, { "name": "sub plan", "size": 50,  "children": [] }, { "name": "valuation", "size": 50,  "children": [] }, { "name": "belief state", "size": 50,  "children": [] }, { "name": "real cost", "size": 50,  "children": [] }, { "name": "IPEM", "size": 50,  "children": [] }, { "name": "online search problem", "size": 50,  "children": [] }, { "name": "stripsapply", "size": 50,  "children": [] }, { "name": "domain file", "size": 50,  "children": [] }, { "name": "stepcost", "size": 50,  "children": [] }, { "name": "problem file", "size": 50,  "children": [] }, { "name": "transition model", "size": 50,  "children": [] }, { "name": "optimal planning", "size": 50,  "children": [] }, { "name": "object", "size": 50,  "children": [] }, { "name": "blocks world", "size": 50,  "children": [] }, { "name": "temporal constraint", "size": 50,  "children": [] }, { "name": "PDDL", "size": 50,  "children": [] }, { "name": "declarative description", "size": 50,  "children": [] }, { "name": "perfect heuristic", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "iamat", "size": 50,  "children": [] }, { "name": "effect", "size": 50,  "children": [] }, { "name": "plan execution", "size": 50,  "children": [] }, { "name": "contingent planning", "size": 50,  "children": [] }, { "name": "blackbox description", "size": 50,  "children": [] }, { "name": "complete", "size": 50,  "children": [] }, { "name": "Sydney", "size": 50,  "children": [] }, { "name": "add link", "size": 50,  "children": [] }, { "name": "stackblock", "size": 50,  "children": [] }, { "name": "preconditions", "size": 50,  "children": [] }, { "name": "blockclear", "size": 50,  "children": [] }, { "name": "Perth", "size": 50,  "children": [] }, { "name": "plan monitoring", "size": 50,  "children": [] }, { "name": "heuristic", "size": 50,  "children": [] }, { "name": "ppercepts", "size": 50,  "children": [] }, { "name": "draft", "size": 50,  "children": [] }, { "name": "Darwin", "size": 50,  "children": [] }, { "name": "relaxed planning", "size": 50,  "children": [] }, { "name": "add step", "size": 50,  "children": [] }, { "name": "drive", "size": 50,  "children": [] }, { "name": "contingency plan", "size": 50,  "children": [] }, { "name": "partial order planning", "size": 50,  "children": [] }, { "name": "goal state", "size": 50,  "children": [] }, { "name": "object variable", "size": 50,  "children": [] }, { "name": "atemporal", "size": 50,  "children": [] }, { "name": "optimal plan", "size": 50,  "children": [] }, { "name": "step", "size": 50,  "children": [] }, { "name": "goaltest", "size": 50,  "children": [] }, { "name": "action schema", "size": 50,  "children": [] }, { "name": "transition function", "size": 50,  "children": [] }, { "name": "result", "size": 50,  "children": [] }, { "name": "online depth first search algorithm", "size": 50,  "children": [] }, { "name": "choice point", "size": 50,  "children": [] }, { "name": "planning task", "size": 50,  "children": [] }, { "name": "systematic", "size": 50,  "children": [] }, { "name": "stripsop", "size": 50,  "children": [] }, { "name": "delreladd", "size": 50,  "children": [] }, { "name": "finish step", "size": 50,  "children": [] }, { "name": "relaxed plan", "size": 50,  "children": [] }, { "name": "actions", "size": 50,  "children": [] }, { "name": "conditional step", "size": 50,  "children": [] }, { "name": "predicate", "size": 50,  "children": [] }, { "name": "empty plan", "size": 50,  "children": [] }, { "name": "frame axiom", "size": 50,  "children": [] }, { "name": "goal state", "size": 50,  "children": [] }, { "name": "delrelpre", "size": 50,  "children": [] }, { "name": "world state", "size": 50,  "children": [] }, { "name": "goal monitoring", "size": 50,  "children": [] }, { "name": "qualification problem", "size": 50,  "children": [] }, { "name": "induced", "size": 50,  "children": [] }, { "name": "pickupblock", "size": 50,  "children": [] }, { "name": "possibly intervening", "size": 50,  "children": [] }, { "name": "replan", "size": 50,  "children": [] }, { "name": "clobber", "size": 50,  "children": [] }, { "name": "benchmark", "size": 50,  "children": [] }, { "name": "plan", "size": 50,  "children": [] }, { "name": "stripsindSP", "size": 50,  "children": [] }, { "name": "adversary argument", "size": 50,  "children": [] }, { "name": "frame problem", "size": 50,  "children": [] }, { "name": "beliefstateprob", "size": 50,  "children": [] }, { "name": "delete list", "size": 50,  "children": [] }, { "name": "onTable", "size": 50,  "children": [] }, { "name": "partially ordered plan", "size": 50,  "children": [] }, { "name": "putdownblock", "size": 50,  "children": [] }, { "name": "unstackblock", "size": 50,  "children": [] }, { "name": "sensorless planning", "size": 50,  "children": [] }, { "name": "OR node", "size": 50,  "children": [] }, { "name": "POP", "size": 50,  "children": [] }, { "name": "stripstrans", "size": 50,  "children": [] }, { "name": "delete relaxation", "size": 50,  "children": [] }, { "name": "Adelaide", "size": 50,  "children": [] }, { "name": "AND node", "size": 50,  "children": [] }, { "name": "stripsstates", "size": 50,  "children": [] }, { "name": "action monitoring", "size": 50,  "children": [] }, { "name": "STRIPS task", "size": 50,  "children": [] }, { "name": "applicable", "size": 50,  "children": [] }, { "name": "planner", "size": 50,  "children": [] }, { "name": "realcostinFN", "size": 50,  "children": [] }, { "name": "causal link", "size": 50,  "children": [] }, { "name": "competitive ratio", "size": 50,  "children": [] }, { "name": "online performance", "size": 50,  "children": [] }, { "name": "IPC", "size": 50,  "children": [] }, { "name": "dead end", "size": 50,  "children": [] }, { "name": "demotion", "size": 50,  "children": [] }, { "name": "offline performance", "size": 50,  "children": [] }, { "name": "delreldel", "size": 50,  "children": [] }, { "name": "fluent", "size": 50,  "children": [] }, { "name": "AND-OR search", "size": 50,  "children": [] }, { "name": "belief state search problem", "size": 50,  "children": [] }, { "name": "safely explorable", "size": 50,  "children": [] }, { "name": "problem description language", "size": 50,  "children": [] }, { "name": "precondition", "size": 50,  "children": [] }, { "name": "sensor model", "size": 50,  "children": [] }, { "name": "frame of reference", "size": 50,  "children": [] }, ] }, { "name": "What did we learn in AI 1?", "size": 50, "children": [{ "name": "MEU principle", "size": 50,  "children": [] }, { "name": "rational", "size": 50,  "children": [] }, ] },
]}


  root = d3.hierarchy(testData)
      .sum(function(d) {
        return d.size; })
      .sort(function(a, b) { return b.value - a.value; });

  var focus = root,
      nodes = pack(root).descendants(),
      view;

  var circle = g.selectAll("circle")
    .data(nodes)
    .enter().append("circle")
      .attr("class", function(d) { return d.parent ? d.children ? "node" : "node node--leaf" : "node node--root"; })
      .style("fill", function(d) {
        // return d.children ? color(d.depth) : null; }) -> vorher
        return d.data.color ? d.data.color : (d.children ? color(d.depth) : null); })
      .on("click", function(event, d) {
        if (focus !== d) zoom(event, d), event.stopPropagation(); });

  var text = g.selectAll("text")
    .data(nodes)
    .enter().append("text")
      .attr("class", "label")
      .style("fill-opacity", function(d) { return d.parent === root ? 1 : 0; })
      .style("display", function(d) { return d.parent === root ? "inline" : "none"; })
      .text(function(d) { return d.data.name; });

  var node = g.selectAll("circle,text");

  svg
      .style("background", color(-1))
      .on("click", function(event) { zoom(event, root); });

  zoomTo([root.x, root.y, root.r * 2 + margin]);

  function zoom(event, d) {
    var focus0 = focus; focus = d;
    var transition = d3.transition()
        .duration(event.altKey ? 7500 : 750)
        .tween("zoom", function(d) {
          var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
          return function(t) { zoomTo(i(t)); };
        });

    transition.selectAll("text")
      .filter(function(d) { return d.parent === focus || this.style.display === "inline"; })
        .style("fill-opacity", function(d) { return d.parent === focus ? 1 : 0; })
        .on("start", function(d) { if (d.parent === focus) this.style.display = "inline"; })
        .on("end", function(d) { if (d.parent !== focus) this.style.display = "none"; });
  }

  function zoomTo(v) {
    var k = diameter / v[2]; view = v;
    node.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
    circle.attr("r", function(d) { return d.r * k; });
  }
//});
}
testFunc()

</script>
